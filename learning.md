# 1.std::atomic(原子操作)

std::atomic原子操作，可以理解为一种不需要用到互斥量加锁(无锁)技术的多线程编程方式；

为何已经有互斥量了，还要引入std::atomic呢，这是因为互斥量保护的数据范围比较大，我们期望更小范围的保护。并且当共享数据为一个变量时，原子操作std::atomic效率更高。

支持的运算符操作: ++、-、+=、 &=、 |=;


# std::bind

之所以用std::bind,是因为函数指针只能指向全局或静态函数，不能指向类成员函数，lambda表达式等，所以用std::bind替代；




# std::forward


# std::unique_ptr



只有事件已经发生的情况下操作非阻塞I/0(读写等)，才能提高程序的效率。因此非阻塞IO通常要和其他IO通知机制一起使用，比如I/O复用和SIGIO信号。
IO复用是最常用的IO通知机制，IO复用函数本身是阻塞的，它之所以能提高效率是因为它能同时监听多个IO事件。



# 事件接收处理模式

服务器通常需要处理三类事件：IO事件，信号及定时事件；
网络设计模式：Reactor(同步IO模型)，Proactor(异步IO模型)
reactor是要求主线程(IO处理单元)只负责监听文件描述符上是否有事件发生，有的话通知工作线程(逻辑单元),除此之外
并发模式探讨服务器IO处理单元，请求队列，逻辑单元之间的协调；
有限状态机是探讨逻辑单元内部的一种高效编程方法，有的应用层协议头部包含数据包类型字段，每种类型可以映射逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。


# I/O和并发的同步异步

1.在IO模型中，"同步"和"异步"区分的是内核向应用程序通知的何种IO事件(是就绪事件还是完成事件),以及该由谁来完成IO读写(是应用还是内核)；
2.在并发模式中，”同步“指的是程序按照代码顺序执行，”异步“指程序的执行需要由系统事件来驱动，常见的系统事件包括中断，信号等；


# 服务器任务调度模型

在半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。


半同步/半反应堆模式是半同步/半异步模式的变体，

                                            主线程
                                （对监听/连接socket调用epoll_wait())
                                              |
                                              |(插入连接的socket)
                                           请求队列
                            |                 |                 |
                        工作线程1         2                  3
                (从工作队列中获取连接socket)

线程池设计模式是半同步半异步：异步线程只有一个，由主线程充当，它负责监听所有socket上的事件，如果监听socket上可读事件发生，即有新的连接请求，主线程将accept接收得到新的连接socket，并往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生 ，即有新的客户请求到来或有数据要读写，主线程就将该连接socket插入请求队列。所有工作线程都睡眠在请求队列上，当有任务来的时候，他们通过竞争(比如申请互斥锁)获取任务接管权。只有空闲的工作线程才有机会处理新任务。

高效半同步/半反应堆模式的一种改进方案是：
主线程只负责监听新的socket连接请求，当有新连接请求时，主线程accept并将该socket连接派发给某个工作线程，此后该socket上的IO读写等事件都有派发的工作线程来处理，直到客户端关闭连接。主线程向工作线程派发socket的最简单的方式是管道。



# 池

池的思想是以空间换时间，池是一组资源的集合，这组资源在服务器启动时就已创建并初始化(静态资源分配),当服务器正式运行时
如果需要相关资源直接从池中获取，无需动态分配，显然这样优化的速度。

## 线程池和进程池

## 连接池

连接池通常用于服务器内部永久连接，由于每个逻辑单元(在登录和注册时)都需要频繁地访问本地的某个数据库，如果每次访问时都向数据库发起连接，访问完毕后释放这样效率太低。
可以使用连接池让服务器和数据库预先建立一组连接集合，当某个逻辑单元需要访问数据库时.pop出一个连接实体，
完成访问后再push回连接池。


# 单例模式

使用单例模式的场景:
网站计数器,通常是采用单例模式实现否则难以同步；

日志系统，一般是用单例，由于共享日志文件一直处于打开状态，因此只能有一个实例去操作，否则不好追加；

数据库连接池一般用单例模式，因为数据库连接是共享资源，采用单例模式维护可以避免由于资源操作导致性能损耗；

总之单例一般用于:
资源共享，避免由于资源操作导致性能损耗；
不同线程之间访问的全局变量。



# 1.项目介绍

## 1.1介绍下你的项目
web服务器这个项目的主要目的是对浏览器的链接请求进行解析处理，处理完之后给浏览器客户端返回一个响应，如图片和视频等，同时还实现了用户登录和注测功能；
项目的大体框架以及主要技术的话，首先服务器后端的处理方式使用了Socket通信，利用IO多路复用同时监听多个请求，解析和处理请求的任务使用预先准备好的线程池，使用Ractor事件处理模式(即主线程只负责监听文件描述符上是否有事件发生，读写数据以及处理客户端请求交给工作线程完成)和半同步/半异步的并发模式来进行服务器IO处理单元，工作队列以及逻辑单元之间的协调处理。

项目的功能模块主要包括http的请求模块，数据库登录和注测模块，以及基于定时器的超时连接关闭模块；

http请求模块主要有三块内容，一是主线程对http的连接请求处理，二是线程池对http报文的解析处理，主要是基于状态机和正则表达式，三是http报文的相应，即http报文解析完成后,根据不同网址的url产生不同响应报文发送给客户端。

数据库登录和注册模块主要有提取用户名和密码，载入数据库表，登录注册效验以及页面跳转，其中用到了基于单例维护的连接池，因为如果每个线程都单独创建一个数据库连接实例效率太低，所以我们预先在连接池里创建一组数据库连接实例。

最后是基于定时器的超时连接关闭模块，主要是为了关闭那些建立连接后长期不交换数据的客户端连接，关闭被占用的文件描述符，避免连接资源被浪费。大体思路是每创建一个新的客户端连接时，都创建一个定时器，定时器记录了每个客户端的超时连接，文件描述符，客户端套接字以及关闭连接的回调函数，然后我们需要用到优先队列来存储定时器，方便每次都能高效的处理最先过期的连接。

项目大体内容大概就是以上这些，面试官您还有什么想要了解的吗？



## 1.2为什么要做这样一个项目
实验室和实习的一些项目都偏向于机器视觉，感觉自身对于后台开发的知识点比较薄弱，因此做了这个的项目加深理解。                                                   


# 2.线程池相关

## 2.1 为什么使用线程池？

假如处理每个业务逻辑时都启动一个新线程，由于线程的创建和销毁都需要时间，会带来巨大的性能开销，所以我们可以通过线程池预先创建好线程，这样不仅可以限制线程数，同时可以避免动态分配的性能开销，将任务传递给线程池而不是为每个任务动态开启一个新的线程提高并发效率;

## 2.2 处理过程中，线程池线程的选择有哪些方式?
随机算法和轮流选取算法

## 2.3如何实现一个简易线程池
1.首先线程池里需要用一个队列来储存任务，这部分的核心在于如何实现任务入队。
(由于一个任务一般可以用一个函数表示，但每个函数的输入参数有可能不同，我们可以采用函数模板同时利用std::bind+std::function将函数和参数封装成一个可调用对象加入队列。)

2.然后是线程池的工作过程。主要思路就是让所有工作线程都睡眠在请求队列上，当有任务来的时候，他们通过竞争(比如申请互斥锁)获取任务接管权。(其中在线程池构造函数中循环创建指定个线程，通过lambda表达式将请求队列和处理逻辑添加到每个线程，其中还设计到同步和互斥等操作)；

同步:条件变量实现同步，类似生产者-消费之模式；
互斥：任务队列的入队出队利用互斥锁；

同步和互斥的区别：
互斥解决的是线程之间对临界区使用的问题，而同步是解决线程之间协同工作的问题；
互斥：某一资源同时只允许一个访问者进行访问(ps:多个线程对同一共享变量进行读写);
同步：一般是在互斥的基础上，通过信号量，条件变量等机制实现线程之间的协同工作;


3.最后是线程池的析构实现，用一个bool变量来存储是否需要停止使用线程池，当需要析构时，唤醒所有线程，并且逐个join；
```c++
class ThreadPool
{
    public:
    ThreadPool(int threadcount = 8): pool_(std::make_shared<Pool>())
    {
        for(int i=0; i<threadcount; i++)
        {
            std::thread([pool = pool_]{
                std::unique_lock<std::mutex> locker(pool->mtx);
                while(true)
                {
                    if(!pool->tasks.empty())
                    {
                        auto task = std::move(pool->task.front());
                        pool->tasks.pop();
                        //task函数若不涉及临界区，可暂时解锁
                        locker.unlock();
                        task();
                        locker.lock();

                    }
                    //当需要析构时，唤醒所有线程，并且逐个join；
                    else if(pool->isclosed) break;
                    //如果任务队列为空，阻塞
                    else pool->cond.wait(locker);

                }
            })
        }

    }


    ~ThreadPool()
    {

    }

    template<calss T>
    //T&& task = std::bind(&WebServer::closecnn_, this, &users_[fd])
    void Addtask(T&& task)
    {
        {
        //std::lock_guard作用域内自动上锁解锁,对象析构时自动解锁
        std::lock_guard<std::mutex> locker(pool_->mtx);
        pool_->tasks.emplace(std::forward<F>(task));
        }
        pool_->cond.notify_one();
        
    }
    

    private:

    struct Pool
    {
        std::mutex mtx; //互斥锁
        std::condition_variable cond; //条件变量
        bool isclose; //使用一个bool变量来存储是否停止使用线程池
        std::queue<std::function<void()>> tasks;
        //所有std::bind封装的可调用实体的返回值都与void兼容
    }
    //智能指针主要的用途就是方便资源的管理，自动释放没有指针引用的资源。
    std::shared_ptr<Pool> pool_;

}



```

## 2.4线程的同步机制有哪些?(**)

互斥锁，信号量，条件变量等；

信号量、共享内存、消息队列等主要关注进程之间的通信;
而条件变量，互斥锁主要关注线程之间的通信；


## 2.5介绍一下几种典型的锁

1.互斥锁
2.条件变量；
3.读写锁
应用场景:多个线程频繁访问临界区，偶尔有一个写线程进入临界区。

特性：
多个读线程可以同时读；
写线程必须互斥(只允许一个写线程，读写线程也不能同时工作)；
唤醒时优先考虑写线程；


4.自旋锁
一般应用于加锁时间很短的场景，如果进程无法获得锁，不会立刻放弃cpu时间片，而是一直循环尝试获得锁直到获得为止。

## 2.6线程池的线程数量选择

线程数选择应针对不同任务性质而言: 计算密集型任务应配置尽可能小的线程，如cpu核数+1，IO密集型任务应尽可能配置多的线程，
如cpu核数*2+1;

## 2.7线程池的工作线程是一直等待吗(**)
线程池的工作线程在任务队列为空时处于阻塞等待模式，当有新的入任务来临时会唤醒。

## 2.8你的线程池工作线程处理完一个任务后的状态是什么?
分两种情况:
1.当处理完任务后任务队列为空，则线程重新回到阻塞等待的状态;
2.当处理完任务后任务不为空，则线程有机会通过和其他线程竞争获得处理任务的资格；


## 2.9如果同时有1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢?(服务器如何处理高并发问题)
首先通过IO复用通知可以同时监控到多个客户端请求；
本项目中是通过子线程循环处理任务请求来解决高并发问题的；
我们创建的子线程处于while循环中，当处理一个任务后会不断处理下一个，没有任务时则阻塞等待，线程池的线程同一时间都在循环处理任务。

## 2.10如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求，有什么好的策略？
会影响，因为线程池的线程有限，同一个线程同一时间只能处理一个客户端请求，假如某个客户请求处理很慢，会导致后续的客户请求堆积在请求队列，无法及时响应；

应对策略：可以为请求队列的每个请求对象设置一个超时时间，超过一定时间还占用线程则直接断开连接；

# 3.并发模型相关

## 简单说一下服务器使用的并发模型
使用的是半同步/半异步模式，异步线程负责处理I/O事件，同步线程用于处理客户逻辑，异步线程只有一个，由主线程充当，如果有新的客户连接请求，主线程将accept接收得到新的连接socket，并往epoll内核事件表中注册该socket上的读写事件。如果有已连接的客户有数据要读写，主线程就将该连接socket插入请求队列。线程池中所有工作线程都睡眠在请求队列上，当有任务来的时候，调度空闲的工作线程处理新任务。

## 你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？

IO多路复用是指让单个线程可以同时处理多个IO请求；

IO复用的方式通常有select,poll,epoll;

select和epoll的文件描述符是在用户态加入,每次调用时需要将所有文件描述符集合拷贝到内核态，epoll则是将监控的文件描述符集合维护在内核态，每次添加文件描述符执行系统调用进行添加。
epoll的优点是可以直接返回满足条件的文件描述符集合，处理时只需要遍历满足条件的文件描述符 
而select和poll处理时需要遍历所有监视的描述符，效率较低；
select有最大连接限制,而Poll和epoll没有；
select和poll都只能在相对低效的电平触发(LT)模式下工作，而epoll同时支持水平触发和边缘触发模式；

边缘触发模式一般和非阻塞I/O搭配，即使socket没有读写数据也会返回结果

三种方式都有其适用的场景
当服务端接入少，并且需要跨平台是可以考虑select;
当检测的fd数目少，且各个fd都比较活跃时，优先考虑select和poll;
epoll更适合高并发的场景，当检测的fd数目非常大，且某个时间处于就绪的文件描述符不多，考虑epoll

IO多路复用之所以能提高并发性能：IO多路复用技术本身虽然是阻塞的，但他可以同时阻塞多个I/O请求；



# 4.http相关

## http连接请求处理

    http连接请求首先是通过epoll在边缘触发模式下搭配非阻塞fd异步通知主线程，然后主线程通过一次循环accept多个连接，并向epoll注册该客户端连接，同时创建该http连接的定时器加入时间堆；

## http报文解析处理

    epoll监听到已连接的http有待读取的请求，将处理任务加入线程池任务队列，通知各工作线程进行处理；
    工作任务包括报文解析和报文响应两部分，循环读取报文每一行(每一通过\r\n判断)，通过状态机和正则表达式进行数据解析及可用字段的检索，分别解析出请求头行，请求头，请求主体三部分的有效字段保存到报文解析类httprequest类的成员变量中(如method, url, header, post bode的username和password )


## http报文响应

200 ok, 400 bad request, 403 forbidden, 404 not found
400.html, 403.html, 404.html;

    http报文解析完成后,根据不同网址的url产生不同响应报文(本项目只涉及了200请求成功，400 请求报文语法错误，404 not found等)，最后将响应报文发送给浏览器。

## 为什么要用有限状态机？
一般应用程序的控制流程基本上是按顺序执行的，如果要实现不同状态间的跳转，可以使用if,else等逻辑判断实现，但代码易混乱不易维护扩展；

HTTP请求报文包括请求行，请求头，请求主体三个部分，每个部分需要单独的处理逻辑进行解析(比如用来解析报文不同部分的正则表达式都是不同的)，所以可以用状态机根据输入解析跳转到不同的状态。

## 状态机转移图

                                                    fd缓冲区无数据
state_line-----------------state_header-----------------------------------------------------------------end
          (解析请求行完成)        |                                                                         |
                                ----------------------------------state_body------------------------------
                                解析完请求头，并且缓冲区还有可读数据              解析完请求主体

## https协议为什么安全？
HTTP协议是运行在Tcp之上的，明文传输；HTTPS相比HTTP多了一层SSL(secure socket layer)协议，是添加了加密和认证机制的HTTP；


## GET和Post的区别
get是从服务器上获取数据，post是向服务器传送数据；
get把参数包含在url中，而post通过请求主体传输数据
get请求在url中传送的参数是有长度限制的；
一般来说get产生一个TCP包,post产生两个TCP包；
对于get请求，浏览器会把http header和data一起发送，服务器响应200返回数据，
对于post请求，浏览器先发送header，服务器响应100continue后，浏览器再发送data，服务器响应200返回数据



# 5.数据库登录注册相关


## 登录注册流程
登录注册分为提取用户名和密码，载入数据库表，登录注册效验，页面跳转四个部分；

1.首先浏览器输入用户名和密码后，发送一个post请求报文，通过解析报文的消息体解析出用户名和密码;
2.其次是载入数据表，通过数据库条件查询，查找出用户名结果集以map容器保存;
3.登录注册效验，登录的话将容器保存的账号密码与解析的账号密码进行比对，相符则登录成功；
注册的话，先查询数据库里是否已经有该用户防止重名，如果没有就插入数据库；
4.当输入用户名和密码相匹配则跳转到对应界面，否则跳转到错误界面；

查询："SELECT username, password FROM user where username='%s'"
插入："INSERT INFO user(username, password) VALUES(%s, %s)"

## 用户状态保存了吗?如果要保存，你会怎么做?

没有保存(保存了，但我不知道在哪)，cookie和session;

cookie实际是一小段文本信息。客户端请求服务器时，如果服务器需要记录用户信息，就使用response向客户端颁发一个cookie。客户端浏览器会把cookie保存，当再次访问该网站，浏览器会把网站和cookie一起提交给服务器。

cookie好比向客户端颁发一个通行证，然后检查通信证确认信息；
session相当于在服务器上建立了客户端的档案，客户端连接时只需查询档案表；


# 6.定时器相关


## 为什么要使用定时器？

主要是为了关闭那些建立连接后长期不交换数据的客户端连接，关闭被占用的文件描述符，避免连接资源被浪费。


linux下提供三种定时方法
1.socket提供的定时接口；
2.SIGALRM信号；
3.IO复用系统调用的超时参数；

本项目采用的是IO复用系统调用的超时参数，我这里用到了epoll_wait函数，他除了能统一处理IO事件还能统一处理定时事件，但是由于IO复用系统调用可能会在超时时间到达之前先触发IO事件，所以需要循环更新定时参数。


定时器类：定时器类的成员变量封装了超时时间，客户端连接的文件描述符，成员函数封装了定时事件的回调函数，作用是到达超时时间就断开该用户连接；

连接资源：包括客户端套接字地址，文件描述符和定时器；

定时容器：最小堆；

## 说一下定时器的工作原理
主循环定时处理非活动连接，其中服务器主线程循环为每一个客户连接创建一个定时器，记录了每个客户连接的超时时间，文件描述符，客户端套接字以及关闭连接的回调函数。
然后维护了一个定时器容器结构，方便每次都能高效的处理最先过期的连接，使用最小堆维护。定时策略是每次将所有定时器中超时时间最小的一个超时值作为epoll_wait的超时参数，这样可以保证每次定时都可以至少一个连接，进行精准定时。

这样每次循环都从最小堆取出最早过期的定时器并执行定时器里的回调函数，
但已连接的客户有读写请求时，还会更新该定时器的定时事件，并调整它在数组中的位置。

定时器怎么通知主循环？
主循环调用epoll_wait函数，超时时间到了会调用回调函数处理超时连接，没到会阻塞。



时间复杂度：
基于升序链表(双向链表):
添加:O(n),  删除O(1), 调整:O(n), 需要用到添加；

基于最小堆的：
最小堆：每个节点的值小于或等于其子节点的值的完全二叉树；

添加O(log(n)), 删除O(log(n)), 调整O(log(n));

也可使用stl的优先队列，但优先队列没有adjust函数
```c++
#include <iostream>
using namespace std;
#include <cmath>
#include <map>
#include <queue>

struct TimerNode {
    int id;
	int expires;
    bool operator<(const TimerNode& t) const{
        return expires > t.expires;
    }
};


int main()
{
	priority_queue<TimerNode> priorityQueue;
	for(int i = 0; i<5; i++)
	{
		priorityQueue.push(TimerNode{i, 5-i});
	}
	priorityQueue.push(TimerNode{0, 0});
	priorityQueue.pop();
	while (!priorityQueue.empty()) {
        TimerNode top = priorityQueue.top();
        cout << "size:" << top.id << " price:" << top.expires << endl;
        priorityQueue.pop();
    }


	system("pause");

}

```

小根堆：
堆是一种完全二叉树，根节点小于子节点，可以采用如vector等容器顺序存储元素，采用数组存储时满足的规律为
若当前节点在数组中索引为i，那么它的左节点的索引是2*i+1,右节点的索引是2*i+2,父节点是(i-1)/2


实现堆最重要的两个方法就是插入和删除方法；
堆的插入方法步骤：每次插入都将元素插入到堆的尾部； 如果不满足堆的特性，则进行调整(上移)直到满足条件；
堆的删除方法步骤:删除根节点后用堆的最后元素进行填充； 如果不满足堆的特性，则进行调整(下移)直到满足条件；


```c++
#include <vector>

#include <algorithm>
class heap
{
private:
    vector<int> heap_;
public:
    void add(int time);

    void pop();

    void adjust(int index, int timeout);

private:
    void siftdown(int index);

    void siftup(int index, int n);

    void del(int index);

    void swap(int i, int j);

}

void heap::add(int time)
{
    //堆尾插入
    int i  = heap_.size();
    heap_.push(time);
    siftup_(i);

}

void heap::siftup(int i)
{
    if(i >= 0)
    {
        int j = (i-1)/2;
        while(j >=0)
        {
            if(heap_[j] < heap_[i])
            {
                break;
            }
            swapnode(i, j);
            
            i = j;
            j = (i-1)/2;
        }
    }
}

void heap::swap(int i, int j)
{
    swap(heap_[i], heap_[j]);
    //fd需要和index记录一个map
}


void heap::pop()
{
    if(!heap_.empty())
    {
        del_(0);
    }
}

void heap::del_(int index)
{
    //将要删除的结点和队尾交换，然后调整堆；
    int i = index;
    int n = heap.size() - 1;
    if(i < n)
    {
        swapnode(i , n);
        //只调整(0,n-1)
        siftdown(i, n);

    }
    //删除队尾元素
    heap_.pop_back();
}

void heap::siftdown(int i, int n)
{
    int j = 2*i + 1;
    while(j < n)
    {
        if(j+1 < n && heap_[j+1] < heap_[j]) j++; //i跟左右子节点小的那个比
        if (heap_[i] < heap_[j]) break;
        swapnode(i, j);
        i = j;
        j = 2*i+1;
    }
}

void heap::adjust(int index, int time)
{
    heap_[index] = time;
    //因为时间一般是延长，所以下浮
    siftdown(index, heap_.size())
}



```






堆排序就是每次重建堆后再调整的过程，如用大根堆实现升序排列，每次堆重建后将根节点与尾节点交换，然后再调整除尾节点之外的节点。
如[87, 45, 78, 32, 17, 65, 63, 9, 63];
->交换
[63,45,78,32,17,65,63,9,87];
再对65-9之间的元素调整，然后再交换；



# 简历
Linux，C++，Socket， MySQL, 多线程，正则，状态机


利用IO复用技术与线程池实现多线程Reactor并发模型，增加并行服务数量；
使用正则与状态机解析HTTP请求报文，支持解析Get和Pos请求，实现静态资源访问；
利用单例模式维护数据库连接池，减少数据库连接建立和关闭花销，实现用户注册和登录功能；
基于时间堆实现定时器，关闭超时的非活动连接；

                                            
个人对多线程间的同步和互斥有了进一步的理解，对于网络编程也有了更清晰的认识。
