# 1.进程管理

## 1.1 进程和线程的区别和联系
### 1.1.1进程和线程的基本概念

进程是系统调度和分配的基本单位，是系统并发执行的单元；
线程是cpu调度和分配的基本单位，它是比进程更小的能够独立运行的基本单位，也叫作轻量级进程；

### 1.1.2进程和线程的区别

引入线程的初衷一是为了避免进程创建时消耗的资源和切换时带来的开销等缺点
所以创建一个线程比创建一个进程占用的资源更少，进程之间的地址空间完全独立没有共享的内存块，而同一个进程下的多个线程共享堆区，全局区等存放的数据，单独拷贝一份栈区的数据。
引入线程的另一个原因是简化进程之间的通信，因为线程之间拥有共享的内存；


### 1.1.3一个进程可以创建多少线程，和什么有关?

理论上，一个进程的可用虚拟空间是2G(1024M*2)，一个线程的栈大小是1M,所以理论上最多只能创建2048个线程；
所以是由进程的虚拟空间大小决定的；


## 1.2 进程和线程之间的通信


### 1.2.1 进程的通信方式
1.管道：管道是一种半双工通信方式，本质是内核的一个缓存，当进程创建一个管道时,会返回两个描述符，一个负责读一个负责写，一个管道数据只能单向流动；

2.消息队列：消息队列是存放在内核中的一个消息链表;

3.共享内存：现代操作系统对于内存管理采用虚拟内存技术，也就是说每个进程都有自己的虚拟空间，虚拟内存映射到真实的物理内存。共享内存就是不同的线程拿出一块虚拟内存空间，映射到相同的物理内存空间；

4.信号：在linux系统中提供了几十种信号(kill-l命令可查看),比如ctr+c产生sigint信号表示进程终止。

5.信号量：信号量是一个计数器，可以控制多个进程对资源的访问。通常作为一种锁机制，实现进程和线程对临界区的同步和互斥访问；

6.SOket套接字：soket一般用于网络编程，可以实现不同主机之间的通信；



### 1.2.2 线程的通信方式

线程之间的通信方式可以通过
1.信号量：信号量是一个计数器，可以控制对个进程和线程对资源的访问。信号量小于等于0时会阻塞；
以信号量实现一个连接池为例：
初始化信号量为连接池容量:sem_init(&semId_, 0, MAX_CONN_);
取走一个mysql连接实例时会先执行：sem_wait(&semId_)，等待信号量大于0，然后执行信号量-1,并从连接队列pop出一个连接实例；
释放一个mysql连接实例时会执行：sem_post(&semId_); 执行信号量加1操作，并将mysql连接实例push；

2.互斥锁

3.条件变量



## 1.3 进程和线程之间的同步和死锁

### 1.3.1 什么是进程同步?
进程的同步是指在多进程/线程下，不同进程、线程之间存在的互斥和协同合作关系；

### 1.3.2 线程和进程同步的方法

1.临界区：访问临界共享资源的代码片段；

2.互斥量

3.信号量

4.条件变量



### 1.3.3 死锁的概念

死锁是指多个线程争夺资源而陷入的一种僵持状态，比如A,B两个线程，A持有锁1，B持有锁2，A等待锁2释放的同时B也在等待锁1释放，这样两个锁都不会释放造成死锁；


### 1.3.4 死锁产生的必要条件

1.互斥条件：一段时间资源仅能被一个线程占有；
2.请求和保持条件：当进程因请求资源阻塞时，不会释放已有资源；
3.不剥夺条件：进程持有的资源不能被强制抢占，只能由进程自己释放；
4.环路等待条件：在发生死锁时，资源分配图必定是闭环；



### 1.3.4 如何检测和解决死锁

检测：采用有向图构建资源分配图，运行另外一个线程定时检测资源分配图是否有环；

解决：撤销进程，强制撤销部分进程并剥夺所占资源；
      挂起某些死锁线程，并抢占它的资源，将这些资源分配给其他死锁进程

## 1.4进程状态切换你知道多少?
就绪状态：等待被调度；
运行状态
阻塞状态:等待资源


只有就绪状态和运行状态可以相互转换，其他的只能单项转换(运行->阻塞->就绪);
就绪状态的进程通过调度算法从而获得cpu时间，转为运行状态，运行状态分配的cpu时间用完之后转为就绪状态；
阻塞状态是由于缺少某种资源由运行态转换而来，这种资源不包括cpu时间；



## 1.5 进程的调度算法你了解哪些?

调度算法主要用于资源的分配；
1.先来先服务算法：任务进程按照先进先出的原则排成一个队列，顺序执行队列中的线程；
2.时间片轮转算法：任务进程按照先进先出的原则排成一个队列，顺序分配时间片给队列线程，当时间片用完，把线程插入队列末尾；
3.优先级调度：为每一个线程分配一个优先级，按优先级顺序调度；
4.短作业优先:按估计的运行时间最短的顺序进行调度；


## 守护进程，孤儿进程，僵尸进程

守护进程：指在后台运行，周期性地执行某种任务的进程，如web服务器进程http等；

孤儿进程：父进程退出，而子进程还在运行，该子进程称孤儿进程。孤儿进程会被进程号为1的初始进程收养(任何一个进程必须有父进程)，并由初始进程对孤儿进程的完成状态进行收集。

僵尸进程：子进程退出，而父进程并未捕获子进程的退出状态，这时子进程并未真正结束成为僵尸进程；
子进程退出后，父进程应调用wait会waitpid函数获取子进程信息，避免僵尸线程；

# 2.内存管理


## 2.1 什么是内存？作用是什么?
内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被cpu处理；

在多道程序下，系统会有多个程序并发执行，也就是说会有多个程序的数据需要同时放入内存，如何区分各个程序的数据是放在什么地方呢？
方法：给内存的存储单元编地址(逻辑地址)
内存地址一般是从0开始的，每一个地址对应一个存储单元，如果计算机是按字节编地址，那么每个地址对应的存储单元的大小为1个字节；

## 2.2 覆盖与交换

内存交换主要是在不同进程(线程)之间进行，而覆盖则是在同一程序或进程中

## 2.3 内存动态分区分配算法

所谓动态分区分配，就是指内存在初始化时不会划分区域，而是会在进程装入时，根据装入的进程大小动态地对内存空间进行划分，以提高内存空间利用率，降低碎片大小；

1.首次适应算法：每次从低地址开始查找，顺序在空闲分区链或空闲分区表中，查找第一个能满足大小的空闲分区；

2.循环首次适应法：分配内存时从上一次查找结束位置开始继续查找；

3.最佳适应算法：空闲分区按容量递增顺序查找，找到第一个能满足的空闲分区；(为了保留更多大分区)

4.最大适应算法：空闲分区按容量递减顺序查找，找到第一个能满足的空闲分区。(防止产生过多太小不可用碎片)


## 2.4 什么是快表，你知道多少关于快表的知识？

快表是一种高速缓冲寄存器，内容是页表中的一部分或全部内容；
在操作系统中引入快表是为了加快地址映射速度；

页表是一种特殊的数据结构，放在系统空间的页表区，存放逻辑页与物理帧的对应关系；


## 2.5虚拟内存
### 2.1 虚拟技术你了解吗?

虚拟技术把一种物理实体转换为多个逻辑实体；

虚拟技术主要有两种：时分复用技术和空(空间)分复用技术。

时分复用技术的案列：多进程多线程采用了时分复用技术，让每一个进程轮流占用处理器，分配时间片快速切换多进程并发；

空分复用的案列:虚拟内存，将物理内存抽象为地址空间，每个进程都有各自的地址空间(这个地址空间被分为很多块，每一块称为一页)地址空间的页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中，当使用到了一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中；
简单说，虚拟内存是操作系统提供的⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。


### 2.2 虚拟内存的目的？

虚拟内存的目的是为了让物理内存扩充为更大的逻辑内存，从而让程序获得更多的可用内存；
因为虚拟内存允许程序不用将地址空间的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存中就可以运行，比如一个只有32k物理内存的计算机能够运行一个64k的程序。


### 2.3 页面置换算法

1.最佳置换法

2.先进先出置换算法

3.最近最久未使用置换算法

4.时钟置换算法

5.改进型时钟置换算法




# 3.文件管理


## 磁盘调度算法






# 4.IO管理


## IO多路复用


# 未分类知识点

## 1.并发和并行的区别?

并行是指同一时间，每个任务都分配给一个处理器(cpu),多个任务会同时进行；
并发是指同一时间，任务不会同时执行，而是来回切换处理不同任务，用到的是时分复用技术；


## 2.同步，异步，阻塞，非阻塞(针对并发模型)
同步和异步关注的是消息通知机制；
同步是指程序按照顺序逻辑运行，当发生调用时需要一直等待返回结果通知，通知之后才能继续往下执行；
异步是指程序执行依赖于某种系统事件，异步调用不需要等待结果通知，可以执行其他逻辑，通知后再执行相应的逻辑；

阻塞和非阻塞关注的是线程等待通知的时的状态；
阻塞是指调用结果返回前，当前线程会阻塞；
非阻塞是指调用结果不返回，也不会阻塞当前线程；

## 3.什么是缓冲区溢出？

缓冲区溢出是指向缓冲区填充的数据超过了缓冲区本身的容量，溢出的数据会覆盖在合法的内存；



## 4.物理地址，逻辑地址，虚拟内存

物理地址是内存单元存储数据的真正地址，程序在访问和读写数据时都是通过逻辑地址映射的物理地址中进行存取的；
逻辑地址是指用户能够看到的地址，比如我们创建一个长度为10的整型数组时，操作系统返回的是一段连续逻辑地址；


## 5.谈谈对动态链接库和静态链接库的理解？

静态链接就是在编译时直接将需要用到的代码拷贝到调用处。优点是在程序发布时不需要依赖库，程序也可以运行，但占的空间会更大；

动态链接就是在编译时不直接拷贝代码，而是在程序执行到指定代码时加载共享内存中的动态库可执行代码。优点是，多个程序可以共享同一段代码，缺点是运行时加载会影响效率；


## 6.外中断和异常中断?

外中断是指由cpu指令以外的事件引起的，比如IO中断，时钟中断，控制台中断等等；
异常中断是由于cpu引起的，比如地址越界，非法操作符等

## 7.什么是用户态和内核态？

用户态和内核态是操作系统的两种运行状态；
处于内核态的cpu可以访问任意数据，包括外围设备，比如网卡和硬盘等；

处于用户态的cpu只能访问执行内存，并且不允许访问外围设备，cpu不允许独占，cpu能被其他程序获取；

总结:数据访问权限不同；

## 8.用户态和内核态如何切换?
操作系统进行系统调用、异常中断和外部中断;


## 9.常见的内存分配错误?

内存分配后未初始化就使用;p==NULL;
地址越界；
忘记释放内存，造成内存泄漏(delete)；
内存释放后未置为NULL造成悬挂指针；

## 10.内存交换中，被换出的进程保存在哪里？

磁盘的对换区，操作系统一般把磁盘分为文件去和对换区；文件区主要存放文件；对换区的IO交换速度比文件区快；