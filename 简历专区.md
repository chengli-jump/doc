# "熟悉STL下常见容器底层数据结构"

## 1.各大容器的特点

1.可用下标访问的容器(既可以插入又可以赋值): vector, deque, map；
2.序列化容器才可以在容器初始化时制定大小，关联式容器不行；
3.关联容器的迭代器不支持it+n操作，仅支持it++操作；


## 2.序列式容器

### 2.1.vector

简述: vector的底层结构是数组，支持O(1)快速随机访问，支持O(1)尾部插入;

特点：
1.vector是一个动态分配的数组，当旧的存储空间不够时，扩充一个新的空间，空间大小为原来的两倍，复制元素到新的空间，并释放旧空间；
2.底层内存连续；
3.对于插入或删除操作，执行效率不高，越靠后的插入或删除执行效率越高；
4.高效的随机访问容器；
5.当删除元素时，不会释放限制空间，所以向量容器的容量(capacity)大于向量容器的大小(size);




### 2.2.deque(双端队列)
简述：底层内存空间不一定连续，通过map数组的指针(指数组的每个元素都是一个指针,指向另外一个较大的连续空间)来管理不同的连续空间，支持快速随机访问，和首尾增删；

特点：
1.具有分段数组，索引数组，分段数组是存储数据的，索引数组是存储每段数组的首地址；
2.向两端插入元素的效率很高；
若向两段插入元素，如果两段的分段数组未满，即可插入；如果两端的分段数组已满，则创建新的分段数组，并把分段数组的首地址存储到deque容器中；


### 2.3.List
简述：list的底层数据结构是一个双向链表 , 支持快速增删, 不支持随机访问，双向迭代器(仅支持++,--);


## 3.容器适配器

容器适配器是根据基本容器类别实现的。

### 3.1.stack

stack的底层一般采用list或者deque实现,元素后进先出；


### 3.2.queue

queue的底层一般采用list或者deque实现，元素先进先出；

### 3.3.priority_queue(优先队列)

priority_queue的底层数据结构是堆heap,采用vector来存储数据，取出最大或最小元素的事件复杂度为O(1), 对于插入或删除，其最坏情况为O(lgn)；



## 4.关联式容器
特点: 关联式容器都是有序的，升序排列，自动排序；
实现的是一个平衡二叉树，每个元素都有一个父节点和两个子节点，左子树的所有元素都比自己小，右子树的所有元素都比自己大；



### 4.1.set和multiset
简述：底层结构是红黑树，红黑树是一种自平衡二叉树;

特点：构造set集合的目的是为了快速检索，去重，排序；
1.使用红黑树，其内部元素自动排序，set不可重复，multiset可重复；
2.每次插值都要调整红黑树，效率有一定影响。

### 4.2.map和multimapd

简述：底层结构是红黑树；

特点：用于去重，打乱重新排序问题，有清晰的一对一关系的问题；
1.map是但映射,multimap是多映射；
2.map和multimap内部自建了一颗红黑二叉树，可以对数据进行自动排序，插入、删除效率高，所以map、multimap里的数据都是有序的，这也是我们通过map简化代码的原因。






### 4.3.unorder_map(哈希表)和unordered_multimap
简述：底层结构为哈希表，查找效率比map更高，适用于查找多的场合；
特点：
与map和multimap的区别是无序，查找相对较快，插入删除相对慢；


红黑树的查询和维护时间复杂度均为O（logn),hash_table的查询时间为O(1);

## 5.什么是STL？
C++STL一般包括了算法，容器和迭代器；
算法包括遍历，查找，排序，复制等常用的算法，以及不同容器特定的算法；
容器就是用来存放数据，包括序列式容器，关联式容器和容器适配器三类；
迭代器就是在不暴露容器内部结构的情况下对容器遍历；


## 6.什么是RALL？什么是智能指针？

RALL的引入是为了实现资源管理，也就是在构造函数中申请内存，在析构函数中释放内存;因为c++在创建对象时会自动调用构造函数，在超出作用域时会自动调用析构函数；所以RALL机制的思想是用类来管理资源，将资源和对象的生命周期绑定；

智能指针是RALL最具有代表的实现，智能指针是采用RALL机制对普通指针的封装。智能指针的本质是一个对象，可以实现自动的内存管理，不用担心忘记释放内存导致内存泄漏。
智能指针的话我接触过的有unique_ptr和shared_ptr，其中unique_ptr没有拷贝构造函数，不支持拷贝和赋值，因此unique_ptr独享管理对象指针的所有权，而且可以通过std:move函数转移所有权；
shared_ptr的原理是使用引用计数实现对同一块内存的多次引用，创建新对象时引用计数器置1，拷贝时，引用计数器加1，调用析构函数时，引用计数器减1，当引用计数为0时，释放内存；


```C++
//shared_ptr的实现
template<class T>
class SharedPtr
{
private:
    size_t* m_count;  //引用计数指针；
    T* m_ptr;  //成员指针；
public:
    //构造函数
    SharedPtr(): m_ptr(nullptr), m_count(new size_t) {};
    SharedPtr(T *ptr): m_ptr(ptr), m_count(new size_t) {*m_count =1};

    //析构函数
    ~SharedPtr()
    {
        --(*m_count);
        if(*mcount == 0)
        {
            delete m_ptr;
            delete m_count;
            m_ptr = nullptr;
            m_count = nullptr;
        }
    }

    //拷贝构造函数
    SharedPtr(const SharedPtr& ptr)
    {
        m_count = ptr.m_count;
        m_ptr = ptr.m_ptr;
        ++(*m_count);
    }
    //拷贝运算符(和拷贝构造获得区别在于，拷贝运算符是拷贝对象给一个已经存在的对象，
    //而拷贝构造是拷贝对象生成一个新实例)
    // Person p5 = Person(p4);    拷贝构造函数传入的参数都是已有对象。不是临时对象
    void operator==(const SharedPtr& ptr) {SharePtr(std::move(ptr));}


    //移动构造
    SharedPtr(SharedPtr&& ptr)
    {
        m_count = ptr.m_count;
        m_ptr = ptr.m_ptr;
        ++(*m_count);
    }
    //移动赋值运算
    void operator==(SharedPtr&& ptr) {SharedPtr(std::move(ptr));}

    //解引用
    T& operator*() {return *m_ptr;};

    //->
    T* operator->() {return m_ptr;};
    //重载布尔运算
    operator bool() {return m_ptr ==nullptr;}

    T* get() {return m_ptr};
    size_t use_count() {return *m_count;}
    bool unique() {return *m_count==1;}
    void swap(SharedPtr &ptr) {std::swap(*this, ptr)};

}

```


```c++
//shared_ptr实例
#include <iostream>
#include <memory>
void main()
{
 
	int a = 10;
	std::shared_ptr<int> ptra = std::make_shared<int>(a);
	std::shared_ptr<int> ptra2(ptra); //copy
	size_t size_1 =  ptra.use_count() ; // = 2
	int s1 = *(ptra.get());// = 10
 
	int b = 20;
	//std::shared_ptr<int> ptrb = pb;  //error
	std::shared_ptr<int> ptrb = std::make_shared<int>(b);
	
	/*
	* 原本ptra2是指向变量a的第二个智能指针，但是这里把它重新assign为指向变量b的智能指针。
	*所以指向变量a的智能指针引用计数减1，指向变量b的智能指针引用计数+1.
	*/
	ptra2 = ptrb; 
 
	size_t size_2 = ptra.use_count();//由2变1
	size_t size_3 = ptrb.use_count();//由1变2
}

```
## 7.迭代器：++it和it++哪个效率更高?

++it效率更高。
前置返回的是一个引用，后置返回的是一个对象，后置会产生临时对象(拷贝构造),所以效率低；

```C++
// ++i实现代码为：
int& operator++()
{
*this += 1;
return *this;
}
```
```C++
//i++实现代码为：
int operator++(int)
{
int temp = *this;
++*this;
return temp;
}
```


## 8.说一下左值引用和右值引用?

右值引用是右值的一个别名，可以延长右值的生命周期；
当然右值引用的主要目的是为了实现移动语义和完美转发；
c++引入右值引用来优化性能，具体来说是通过移动语义来避免没有必要的拷贝问题，通过移动语义(移动语义就是把旧指针的值复制到新指针，并把旧指针的值赋为NULL。)将临时对象中的资源无代价的转移到另一个对象中；
移动语义的具体体现就是移动构造函数，移动构造的参数是右值引用，是为了解决深拷贝带来的性能问题，通过浅拷贝直接拷贝原对象，并将原对象的指针成员置为NULL;


右值引用还可以实现完美转发，完美转发是指一个函数模板把收到的参数以及参数类型(比如左值引用或右值引用)不变的转发给其他函数，这样其他函数就可以根据引用类型，执行相应的重载函数；

完美转发实现是使用万能引用(模板参数修饰的&&或const修饰的左值引用，能接受右值和左值)，和std::forward(保留语义，右值引用的返回值是右值引用，左值引用的返回值左值引用)实现;



## 9.STL中的哈希表实现?

哈希表是一种能够结合了数组查询速度和链表增删速度的数据结构；
通过散列函数可以将一个比较大的索引映射到一个比较小的索引，但映射时不同的值计算的结果值有可能是一样的，这就叫哈希冲突；
STL中的unordered_map就是用哈希表实现的，通过开链法解决hash冲突，哈希表是利用一个vector，其中每个元素是一个链表，如果关键值映射的索引值相同则顺序存放在链表中；


## 10.vector与list的区别和应用?

vector和数组类似，内存空间连续能高效进行随机访问，但插入和删除时会造成内存拷贝，时间复杂度为O(n)；
vector是动态扩容的对象数组；

list是双向链表实现的，内存空间不连续。只能通过指针访问数据，不能随机访问，但插入和删除效率高，只需要更改指针指向；

区别：vector随机访问效率高，非尾部插入和删除效率低；
list随机访问效率低，需要遍历链表，插入和删除效率高，只需改变指针指向；



## 11.容器内部删除和插入一个元素后，迭代器会发生什么变化

迭代器失效的两种情况:
1.迭代器对象已经变成了"野指针",对其进行*,++,--都会引起程序内存异常；
2.迭代器对象所指向的内容已经不是所期望的内容，也称迭代器失效；


插入操作：
对于vector而言，插入引起了容器内存重新分配，迭代器，指针都会失效；
如果没有引起内存扩容，那么插入以及之后的迭代器失效(内容变了)；

删除操作：


对于vector而言，erase迭代器会让被删除元素以及之后的迭代器失效，所以不能使用erase(it++)，但erase(iterator)会返回下一个有效的迭代器；
对于list而言，它内存分配不连续，插入和删除不影响迭代器；
对于关联式容器map和set等，erase迭代器只是被删除元素迭代器失效，但是返回void，可以采用erase(it++)删除迭代器；

## 12.迭代器是怎么实现的， 有了指针为何还要迭代器？

迭代器是一个类模板，它将指针进行了进一步的封装，同时还重载了指针的一些操作符++,--,*，->等，相当于一种智能指针；

迭代器产生的原因是为了在不暴露内部结构的情况下循环遍历集合，将不同集合类的访问逻辑抽象出来；


## 13.STL里resize和reverse的区别？

resize()改变容器元素的数量，不改变容器的容量；
当capacity()不足时，会新分配一个原空间大小两倍的空间；

reverse()是改变容器容量的大小；


## 14.map和set底层实现是什么，红黑树是怎样同时实现两种容器的，为什么使用红黑树

map和set都是用红黑树实现的，因此插入和删除等操作的时间复杂度为O(logn)，能高效插入和删除；

用一个模板类，如果参数是key那么就是set，如果参数是键值对那么是map；map的节点是键值对，而set的节点是value;

使用红黑树的原因是因为map和set都要求自动排序，红黑树能够以较低复杂度实现；


## 15.vector和map的越界访问下标? map的find和[]的区别？

通过下标访问vector的元素时会做边界检查，确保访问不会出现错误；
通过下标访问map时，如果不存在key，就会为该键插入一个默认的value，然后返回默认的value；

map的下标运算符[]，是为了查找key对应的值，如果不存在key，就会为该键插入一个默认的value，然后返回默认的value；
map的find函数是为了查找元素键为key的迭代器，如果不存在key，直接返回end迭代器表示未查找到；



## 16.hashtable中解决冲突有哪些方法？
1.线性探测，使用hash函数如果映射出的位置已被占有，则依次向后寻找(到达尾部则从表头开始),直到探测到一个空位；

2.开链法，每个表格维护一个list,hash函数如果映射出额位置相同，则顺序放入链表之中；

3.再散列，发生冲突时，使用另外一种hash函数再计算一个位置，直到不冲突；

## 红黑树
红黑树的引入是由于，



## 链表，栈，队列，二叉树

栈和队列都属于线性表，线性表是一种强调一对一的线性结构，有顺序表和链表两种，区别在于顺序表存储空间连续，链表存储空间不连续；

栈的结构特点是后进先出，可以实现很多功能，比如浏览器的回退功能，底层使用的就是栈存储结构，当依次关闭网页A，B时，网页A，B依次入栈，回退时先看到的是网页B然后才是网页A，这就是栈后进先出的特点

栈的应用之函数调用和递归，递归就是一个函数不断调用自己的过程，而对于每一层递归，函数的局部变量，参数值以及返回地址都被压入栈中，退出时后调用的函数的局部变量，参数值等处于栈顶先弹出，显然递归的回退满足栈存储结构的特点。

栈还可以用于括号匹配等等，树的深度优先搜索；

队列的结构特点是先进先出，可以应用于树结构的广度优先搜索(层次遍历)，C++ stl的队列容器底层是用的队列
消息队列，消息队列一般用于进程间的通信,是存放在内核中的一个消息链表;
进程调度算法的先来先服务算法和时间片轮转算法，都用到了队列，将任务进程按先进先出的原则放入队列，顺序执行；

二叉树

二插搜索树，树的左节点小于父节点，右节点大于父节点，是一种高效的搜索结构；
平衡二叉树，是一颗空树或左右两个子树的高度差绝对值不超过1，主要是为了防止二叉搜索树在搜索有序数据时，时间复杂度退化诚O（n);
堆排序


## 顺序表和链表的区别?
顺序表底层采用的是连续的地址内存，而链表的数据存储空间不连续；
顺序表支持随机访问，可以通过下标访问，中间插入和删除数据需要进行元素移动，插入和删除效率较低；

链表适合插入删除较多的场景，因为插入和删除只需要修改指针指向；






# C++ 11新标准

## 1.智能指针

智能指针是RALL最具有代表的实现，智能指针是采用RALL机制对普通指针的封装。智能指针的本质是一个类，可以实现自动的内存管理，不用担心忘记释放内存导致内存泄漏。



智能指针的话我接触过的有unique_ptr和shared_ptr，其中unique_ptr没有拷贝构造函数，不支持拷贝和赋值，因此unique_ptr独享管理对象指针的所有权，可以通过std:move函数转移所有权(赋值原指针个目标指针，并将原指针置为NULL)

shared_ptr的原理是使用引用计数实现对同一块内存的多次引用，创建新对象时引用计数器置1，拷贝时，引用计数器加1，调用析构函数时，引用计数器减1，当引用计数为0时，释放内存；



## 2.lambda表达式

lambda表达式是实质上是一种仿函数，提供类似匿名函数的特性；
(仿函数就是函数对象重载()操作符)
lambda表达式的语法为[capture-list]{params}->ret{body}
捕获列表，参数列表，返回类型，函数体，其中捕获列表和函数体是不可省略的；

lambda的捕获列表可以通过传值或者传引用的方式捕获其封装作用域的变量，返回一个右值;
捕获列表具体分类：
[]:默认不捕获任何变量；
[=]:默认以值传递捕获所有变量；
[&]:默认以引用传递捕获所有变量；
{x}:仅以值捕获捕获x；
[&x]：仅用引用传递捕获x；
[=,&x]：默认以值捕获捕获所有变量,x列外，采用引用捕获；
[&,x]：默认引用传递捕获所有变量,x除外，采用值捕获；
[this]:通过引用传递捕获当前对象[赋值指针]；
[*this]：通过值传递捕获当前对象；

lambda的另一个作用是可以当做函数的参数，从而实现回调函数的功能；

```c++
int val = 3;
vector<int> v {1, 8, 5, 3, 6, 10};
int count = std::count_if(v.beigin(), v.end(), [val](int x) { return x > val; });
```


## 3.右值引用

右值引用是右值的一个别名，可以延长右值的生命周期；

当然右值引用的主要目的是为了实现移动语义和完美转发；

c++引入右值引用来优化性能，具体来说是通过移动语义来避免没有必要的拷贝问题，通过移动语义(移动语义就是把旧指针的值复制到新指针，并把旧指针的值赋为NULL。)将临时对象中的资源无代价的转移到另一个对象中；
移动语义的具体体现就是移动构造函数，移动构造的参数是右值引用，是为了解决深拷贝带来的性能问题，通过浅拷贝直接拷贝原对象，并将原对象的指针成员置为NULL;


右值引用还可以实现完美转发，完美转发是指一个函数模板把收到的参数以及参数类型(比如左值引用或右值引用)不变的转发给其他函数，这样其他函数就可以根据引用类型，执行相应的重载函数；

完美转发实现是使用万能引用(模板参数修饰的&&或const修饰的左值引用，能接受右值和左值)，和std::forward(保留语义，右值引用的返回值是右值引用，左值引用的返回值左值引用)实现;


## 4.基于范围的for循环

```c++
int arr[5];
std::vector<int> v;

for(int x: arr);
for(const int& x:arr);
for(int x:v);
for(auto &x:v);

```


## 5.auto和decltype类型推导；

auto关键字可以通过初始值来进行类型推导，从而得到变量的类型；

```c++

//普通；类型
int a = 1, b = 3;
auto c = a + b;// c为int型
```


decltype可以推导表达式的类型，当我们只想利用表达式的类型却不想利用表达式的值区初始化变量时可以用decltype；
```c++
int func() {return 0};
//普通类型
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()

int a = 0;
decltype(a) b = 4; // a的类型是int, 所以b的类型也是int


```


# C++ 内存管理

## 1.c++中关于类对象所占内存大小的计算
简单来说，一个类对象所占空间大小为非静态成员变量加上内存对齐加上指向虚函数表的指针；

具体来说：
c++的每个空类的对象也占一个字节；
静态成员变量和成员函数不占空间；
如果类中有虚函数,那么需要一个指向虚函数表的指针


## 2.c++中的内存分区

c++在代码运行时会将内存分为四个区域

首先是代码区， 代码区存放了函数体的二进制编码，由操作系统进行管理；
全局区，全局区存储全局变量和静态变量以及常量等；
然后是栈区，栈区内存由编译器自动分配和释放，一般存放函数的参数值，局部变量等等；
最后是堆区，堆区一般用于动态内存分配，由程序员分配和释放，比如用new和delete操作符进行分配和回收内存

不同区域存放的数据，拥有不同的生命周期，给予了编程更大的灵活性；


## 3.this指针

this指针是指向类对象的首地址；
this指针只有非静态成员函数拥有，全局函数和静态函数没有this指针；

this指针的作用是通过将this指针传递给非静态成员函数，使成员函数可以区分是哪个对象在调用，this指针由编译器自动生成。

this指针的用途：
当形参和成员变量同名时，可用this指针来区分
在类的非静态成员函数中返回对象本身，可使用return *this


可以使用智能指针来避免;

## 4.什么是内存泄漏，如何检测？ 解决办法？

分配内存后未释放会导致内存泄漏，如果存在大量未释放的指针会导致系统可用内存越来越少，甚至内存用完之后会导致系统崩溃；

可以使用智能指针来避免;



## 6.简述一下堆区和栈区的区别

内存管理角度：
栈区是由编译器分配和释放内存，一般用于存放函数参数和局部变量等；
堆区一般是动态分配内存，由程序员管理，c++中用new/delete操作符进行分配和释放资源；

是否产生碎片：
堆区由于分配和释放由程序员控制，频繁操作会造成内存空间不连续，产生内存碎片；
栈区是后进先出结构，在某一数据弹出之前，它之前的所有数据都会弹出，不会产生碎片；

内存生长方向：
堆区的内存分配是沿内存地址增加的方向；
栈区的内存分配是往内存地址减小的方向；

## 7.简述一下c++的内存对齐？结构体占用多少空间？

一个结构体所占的空间大小等于成员变量加内存对齐的大小；

计算机系统对基本数据类型在内存中存放的位置是有限制的，它们会要求这些数据的首地址的值时4或8的倍数，这就是内存对齐；

对齐的原因：
当内存不对齐时，一个成员变量需要多次读取，之所以要对齐本质上是以空间换时间；

对齐规则：

x86(Linux默认#pragma pack(4)， Window默认#pragma pack(8))。Linux最大支持4字节对齐。

方法：

1) 取pack(n)的值 (n = 1, 2, 4，8......)，取结构体中类型最大值为m。两者取小即为外对齐大小 Y = (m < n ? m: n)；

2) 将每一个结构体的成员大小与Y比较取小者为X，作为内对齐的大小；

3) 所谓按X对齐，即为地址(设起始地址为0)能被X整除的地方开始存放数据；

4) 外部对齐原则是依据Y的值(Y的最小整数倍)，进行补空操作；

举例：
typedef struct stu
{
    char a;
    short b;
    int c;
} Stu;

a) Windows平台，pack默认为8。先求外对齐大小Y，结构体中类型最大的为int类型，大小为4字节，4比8小，所以Y值为4.

b) 然后将结构体中的每一个成员与Y进行比较，依次求内对齐的大小。结构体中成员分别为char 1字节，short 2字节，int 4字节，与4(外对齐大小Y)比较，得到内对齐大小分别为 1， 2， 4。

c) 假设起始地址为0x00，0可以被1整除，可以存放a了。a为char类型，大小为1个字节。接着地址为0x01，但是0x01不能被2整除，然后下一个地址为0x02，0x022可以被2整除，因此b的起始地址为0x02(此时，a与b之间填充了一个字节)。b为short类型，大小为2个字节。接着地址到了0x04，它可以被4整除，于是可以存放c了，c为int类型，大小为4个字节。

d) 接着地址到了0x08，(0x08-0x00)它可以被4(外对齐大小Y)整除，满足外对齐要求。

经分析，结构体大小为1 + 1 + 2 + 4 = 8个字节。

typedef struct stu
{
    int c;
    short b;
    char a;
 
} Stu;

a) Windows平台，pack默认为8。先求外对齐大小Y，结构体中类型最大的为int类型，大小为4字节，4比8小，所以Y值为4。

b) 然后将结构体中的每一个成员与Y进行比较，依次求内对齐的大小。结构体中成员分别为int 4字节，short 2字节，char 1字节，与4(外对齐大小Y)比较，得到内对齐大小分别为4, 2，1。

c) 假设起始地址为0x00，0x00可以被4整除，可以存放c了。c为int类型，大小为4个字节。接着地址为0x04，0x04可以被2整除，b为short类型，大小为两个字节。然后下一个地址为0x06，0x06可以被1整除，可以存放a，a大小为1个字节。

d) 接着地址到了0x07，(0x07-0x00)不能被4(外对齐大小Y)整除，为满足外对齐要求，后面需要填充1个字节。

经分析，结构体大小为：4 + 2 + 1 + 1 = 8个字节。

# C++ 面向对象

## 1.构造函数，拷贝构造函数和赋值运算符的区别

构造函数和拷贝构造函数用于对象的初始化，即对象一开始不存在，
只不过构造函数不用别的对象进行初始化，拷贝构造函数使用别的对象进行初始化；

赋值运算符是对象已存在，用别的对象给他赋值；


## 2.C++继承的权限问题

public继承：
父类            子类
public   ->    public
protected ->  protected
父类private不能被继承；public继承,子类访问权限保持同级；

protected继承
public    ->   protected
protected ->   protected
父类private不能被继承；protected继承，子类访问权限降级为protected;

private继承
public   ->   private
protected ->  private
父类private不能被继承；private继承，子类访问权限降级为private;


## 3.模板的实现一定要写在一个文件里吗？

模板的声明和定义都要写在头文件里；

模板类或函数的实现并不能被编译成二进制代码，链接会出错；

## 4.多继承的优缺点？ 什么是菱形继承？ 虚拟继承的目的？

多继承：
c++允许一个派生类指定多个基类，这样的继承结构被称做多重继承；

多继承的优点在于对象可以调用多个基类接口；

缺点在于当继承的多个基类有成员同名时，如果直接访问会出现不确定性，即同名二义性，可以用过作用域符号::指定基类成员 p.B::m_a;

菱形继承：
菱形继承时多继承的一种特殊情况；

两个派生类继承同一个基类;
又有某个类同时继承者两个派生类;

菱形继承会出现同名二义性 和数据冗余(即间接基类的数据被继承了两份，其实只需要一份)等问题；


虚继承：

为了解决多继承的命名冲突和数据冗余问题，c++提出虚继承，使得派生类只能保留一份间接基类成员；


## 5.为什么拷贝构造函数必须使用引用传递不能传值？

值传递会自动调用拷贝构造函数( func(person p1) ->> person p1 = p2)，导致拷贝构造函数无限递归；

引用传递最终传递的是指针类型，属于简单类型，按简单类型的赋值拷贝，不会有拷贝构造函数的调用；


## 6.静态函数能定义成虚函数吗?

不能
静态函数不属于任何类对象，所有类对象共享，没有this指针；
虚函数依靠虚函数表里的函数指针来调用，而函数指针存放在对象空间，并且只能通过this指针访问，静态函数没有this指针不能调用虚函数；


## 7.虚函数的代价？

带虚函数的类中，会产生一个虚函数表用来存储指向虚函数的函数指针，会增大类；
带虚函数的类对象中，都有一个指向虚函数表的指针，会增加对象的空间大小;




# C语言知识点


变量其实只不过是程序可操作的存储区的名称。

## 1.define和typedef的区别?

共同点：define和typedef都可以给一个对象取一个别名；

区别：#define是预处理中的宏定义命令，在预处理阶段进行简单的字符串替换，可以为类型和数值定义别名;
typedef是关键字，在编译时处理，有类型检查功能，为类型定义别名;

用法区别：
#define可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。例如：

```c++
#define INTERGE int;
unsigned INTERGE n;  //没问题
typedef int INTERGE;
unsigned INTERGE n;  //错误，不能在 INTERGE 前面添加 unsigned
```


在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：
```c++
#define PTR_INT int *
PTR_INT p1, p2;        //p1、p2 类型不相同，宏展开后变为int *p1, p2;
typedef int * PTR_INT
PTR_INT p1, p2;        //p1、p2 类型相同，展开后变成int *p1, int *p2;
```

总的来看typedef比define灵活一点；


## 原码，反码，补码

整数5

原码:一个整数按绝对值大小转换为二进制
00000000 00000000 00000000 00000101

反码:将原码按位取反
11111111 11111111 11111111 11111010


补码：反码加1
11111111 11111111 11111111 11111011

负数的原码以其正值的部门表示；








# 项目简述

## AI视觉软件

### 项目背景
该项目是基于西门子智能化末端的包装产线的一个视觉软件系统，目的是为了辅助plc模块的包装生产，利用摄像头代替人的眼睛避免包装时模块附件出现漏装或者误装；

### 我的工作
我的工作主要是针对一些新的产品需求，进行功能拓展并进行代码流程逻辑重构，其中包括新产品附件(EM模块)的智能附件检测功能以及程序状态机的流程逻辑设计等等。最终是实现了一个新型号模块的在线生产。
(为什么用状态机，因为之前产品比较单一，涉及到的流程分支比较少，但后面随着产品的增加以及检测流程的完善，涉及到的流程分支比较多，如果继续使用if-else实现，代码逻辑易混乱不易维护拓展)


### 项目业务功能
整个项目的业务主要实现了智能附件检测，自动扫码，混线包装，MES产品信息系统交互等功能；

### 项目技术主体
整个软件的框架是采用MVC框架，通过控制器完成模型和界面的交互，将模型和界面相互分离；
其中模型包括了视觉检测模型和状态机模型，视觉检测模型负责通过摄像头逐帧目标检测并将结果通知给控制器，状态机模型的任务是根据当前的视觉模型检测到的附件以及所处的状态进行状态切换；
界面包括了不同型号产品及不同检测阶段的多个界面;


项目主要涉及三个线程，主线程是控制器部分，主要负责监控模型状态和UI界面更新，
视觉检测模型和状态机模型分别在不同的子线程中并行运行；(为了让视觉检测模型能够实时检测单独放入一个线程，状态机模型也需要实时切换也单独放在一个线程)；
视觉模型线程的主体部分是一个循环，循环检测每一帧， 状态机工作线程主体也是一个循环，循环执行state类的类方法，根据当前的检测列表项，进行状态切换；(视觉模型负责将检测结果写入结果列表，状态机模型负责读结果列表，有临界区，需要用互斥锁)；



另外还利用了消息订阅模式，让控制器订阅视觉模型和状态机模型，这样一旦模型有了变化他会自己通知控制器，并且根据当前状态选择相应的逻辑处理函数。


state模式将每个状态要实现的特定功能都封装在一个state子类中，通过多态性维持同一的state接口，实现操作和状态之间的解耦。(维持state接口，用到的是多态，父类指针指向子类对象)

利用状态机模式完成业务逻辑的跳转，将每一个逻辑状态抽象为一个子类，子类中封装了该状态应该要进行的操作，这样我们可以将状态和操作绑定，只关注状态切换。

由于视觉检测类记录的检测结果属性应当作为全局变量，允许状态机线程和控制器线程进行访问，所以我们用单单例模式维护了视觉检测类；
状态机每种状态也没必要有多个对象，同样是单例


### QT相关

#### 用到过QT哪些模块？
QT Core模块，提供一些非GUI核心功能，包括定时器，各种容器类，信号槽机制等等；
QT Gui模块，提供GUI程序的基本功能，包括与窗口系统集成等等；
QT Widgets模块主要用于构建用户界面，包括一些用于输入和显示的控件，比如Qpushbutton，Qlineedit，Qlabel等等

# 面经


## 7.28 兴业数金

### 1.内存分区

c++在代码运行时会将内存分为四个区域

首先是代码区， 代码区存放了函数体的二进制编码，由操作系统进行管理；
全局区，全局区存储全局变量和静态变量以及常量等；(全局静态区和全局常量区)
然后是栈区，栈区内存由编译器自动分配和释放，一般存放函数的参数值，局部变量等等；
最后是堆区，堆区一般用于动态内存分配，由程序员分配和释放，比如用new和delete操作符进行分配和回收内存

不同区域存放的数据，拥有不同的生命周期，给予了编程更大的灵活性；


### 2.模板编程

模板编程是c++泛型编程思想的体现，主要是为了提高复用性减少代码重写，将类型参数化；

模板分为函数模板和类模板；
函数模板是建立一种通用的函数，函数的返回类型和参数类型可以不具体指定，用一个虚拟类型代表，将类型参数化；
函数模板有两种使用方式，自动类型推导和显示指定类型，自动类型推到只有推导出一致的类型T才可以使用；

类模板是建立一种通用类，其中类成员的数据类型可以不具体指定，类模板使用时通常需要显示指定类型；

### 3.指针和引用

本质区别：
	引用是变量的别名，本质在c++内部实现是一个指针常量，占8个字节，通过可直接访问数据；

    int& ref = a; 
    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改

	指针变量是一个变量，存放的是指针即变量的地址, 在64位系统上占8个字节，通过地址间接访问数据；

使用区别：
    指针指向可以改变，引用一旦初始化，就不能是其他变量的别名，因为指针常量的指针指向不能改变；
    通过sizeof计算引用时大小是变量的内存空间，而计算指针是是指针变量的大小；
    引用自加1相当于变量加一，指针自加1相当于地址增加了一个变量的大小；


### 4.重写和重载和区别？

重载是发生在同一作用域中，有函数重载和运算符重载，函数重载是复用函数名，返回类型相同，而参数列表不同；
重写一般发生在动态多态子类重写父类的虚函数，重写的函数名，函数返回类型，参数列表相同；

隐藏是指派生类屏蔽了基类的同名函数，只需要函数名相同；
当函数参数相同时，和重写的区别在于基类没有虚函数；


### 5.值传递的方式

值传递，传递的是对象的内容，如果值很多将会比较耗时；
指针传递，本质上也是值传递，传递的是实参指向对象的地址值，拷贝数据占8个字节；
引用传递，本质上传递的实参地址，相当于为地址取了个别名,不会开辟新的内存空间，拷贝地址占8个字节；
指针传递和引用传递比值传递效率更高；


### 6.socket编程有哪些步骤？
服务端编程：
1.调用socket函数创建套接字；
2.调用bind函数分配IP地址和端口号；
3.调用listen函数转换为可接受请求状态；
4.调用accept函数接收套接字请求；
5.用返回的客户端套接字和客户端进行通信(读写)；
6.关闭套接字；

客户端编程：
1.调用socket函数创建套接字；
2.调用connect函数并传入客户端套接字和服务器ip和地址等参数，发起连接请求；
3.和服务端进行通信(send()/recv());
4.关闭套接字；




### 7.epoll的用法

epoll是多路复用的方式之一，能让单线程同时处理多个IO请求;

epoll的使用一般涉及3个api
1.epoll_create, 创建一个文件描述符；
2.epoll_ctl， 添加需要监控对象的文件描述符，比如新的客户端连接；
3.epoll_wait, 阻塞并等待新的事件；


epoll一般搭配边缘触发模式和非阻塞IO使用




### 8.Sql查找优化


### 9.只有2G大小的PC机，在一个存有10G个整数的文件，找到中位数


思路一：堆排序(转换为求前5g大的元素)

利用堆排序可以处理海量数据的topk问题，因为它不用将所有元素都进行排序，只需要维护一个k大小的堆(如果能存下k个数的话)，然后将未遍历的元素和根节点比较大小关系即可，同时也不需要一次性将所有数据加载到内存中。


求前k小的思路：构建一个k个数的最大堆，当读取的数大于根节点时，舍弃；当读取的数小于根节点时，替换根节点，重塑最大堆，然后继续读取，读取所有的数据之后，最大堆的数就是最小的k个数；

利用1g大小的堆从10g元素中查找TOP5g元素思路：
先构建一个1G大小的大根堆，然后依次遍历磁盘的数据，大于根节点的，舍弃，小于根节点直接替换根节点，遍历完可求第1g大小的数；
然后利用该元素构建一个新的1g大小的堆，其中该元素需放在堆尾，然后遍历磁盘的数据，大于根节点的舍去，小于根节点且大于堆尾节点的直接替换根节点，遍历完可求第2g大小的数；
...
每次构建一个求第几G大小的堆，都要重新遍历完所有10G的数据，所以时间复杂度为 5 * 10G(kn),需要频繁的IO操作，不断的从硬盘中读数据；


```c++
int k = 1000
class max5k
{
public:
    top5k(vector<int>& nums, int 10k)
    {
        priority_queue<int, vector<int>, less<int>> pq;
        for(int i=0; i<k; i++)
        {
            pq.push(nums[k]);
        }
        //top k
        for(int i=0; i<10k; i++)
        {
            if(nums[i] >= pq.top())
            {
                continue;
            }
            else
            {
                pq.pop();
                pq.push(nums[i])
            }
        }
        int topk = pq.top();

        //以topk建立1k的堆
        int count = 0;
        for(int i=0; i<10k; i++)
        {
            if(nums[i] > topk)
            {
                count++;
                pq.pop();
                pq.push(nums[i]);
            }
            if(count == 10k)
            {
                break;
            }
        }

        //以topk为基准，求top2k
        for(int i=0; i<10k; i++)
        {
            if(nums[i]>topk && nums[i] <pq.top())
            {
                pq.pop();
                pq.push(nums[i]);
            }
            else if(nums[i] >= pq.top())
            {
                continue;
            }
        }

        int top2k = pq.top();
      
    }
}



```



### 10.进程之间的通信有哪些？



### 11.STL的迭代器怎么实现的？

迭代器是一个类模板，它将指针进行了进一步的封装，同时还重载了指针的一些操作符++,--,*，->等，相当于一种智能指针；

迭代器产生的原因是为了在不暴露内部结构的情况下循环遍历集合，将不同集合类的访问逻辑抽象出来；



## 网上面经

### 1.TCP三次握手分别对应socket编程的哪个阶段?

在客户端发起connect与服务端接收accept之间；


### 2.epoll和select的底层实现及区别?


Select每次循环调用时，都需要将描述符和事件拷贝到内核空间；epoll只需要拷贝一次；

epoll直接返回满足条件的文件描述符集合，而select返回所有集和需要遍历所有文件描述符；

select有最大连接限制，而epoll没有；

select只能在效率相对低下的水平触发模式下工作，而epoll既支持水平触发模式又支持边缘触发模式；

### 3.多线程join和detach的区别?

调用join()后，主线程在子线程执行完之前会阻塞；
调用detach后，主线程和子线程分类，不需要等待子线程执行完毕，子线程执行完毕后会自己释放资源；


### 4.实现string类，构造，拷贝构造，析构，赋值运算符；


```c++
class string
{
public:
    //1.构造函数
    string(const char *str == NULL) //const变量必须初始化
    {
        if(str == NULL)
        {
            m_data = new char[1];
            m_data[0] = '\0';
            m_size = 0;
        }
        else
        {
            m_size = strlen(str);
            m_data = new char[m_size+1];
            strcpy(m_data, str);
        }
    }
    //2.拷贝构造函数
    string(const string& str)
    {
        m_size = strlen(str);
        m_data = new char[m_size+1];
        //由于m_data是私有变量不能访问，所以需要通过c_str访问.
        // strcpy(m_data, str.m_data);
        srecpy(m_data, str.c_str());

    }

    //3.析构函数
    ~string()
    {
        delete[] m_data;
    }

    //4.赋值运算符重载
    string& operator=(const string& str)
    {
        if(this == &str) //加分点，自赋值
        {
            return *this;
        }
        delete[] m_data; //释放原来的内存
        m_size = strlen(str);
        m_data = new char[m_size+1];
        strcpy(m_data, str.c_str());

        return *this
    }


private:
    char *m_data;  //字符串；
    size_t length; 

}

```

### 5.一个共享指针在多线程间如何控制?

share_ptr的引用计数本身是安全无锁的，但对象的读写不是;

当多个线程读写同一个 shared_ptr 对象，需要加锁;

### 6.独占智能指针是如何保证它的独占?

unique_ptr 没有拷贝构造函数，不支持拷贝和赋值，
因此unique_ptr独占对象指针的所有权，
而且可以通过std:move函数转移所有权；


### 7.qt的信号和槽机制?


信号和槽机制类似观察者模式，信号是被观察者，槽是观察者，也就是说当信号发生时，被连接的槽函数会被自动回调；


### 8.如何实现一个单例模式，如何保证它的线程安全?

实现时要注意多线程安全，即：防止多线程同时进入造成 instance 被多次实例化。
解决办法是加锁，另外最后用双重效验，因为单效验每次获取实例都需要加锁，影响效率;