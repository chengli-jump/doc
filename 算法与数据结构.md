# 常用的排序算法
## 1.快速排序

平均时间复杂度也是O(nlogn)
### 1.1递归解法
```C++

int partition(vector<int>& nums, int l, int r)
{
    //与nums[l]作为基准
    int i=l, j=r;
    while(i<j)
    {
        while(i<j && nums[j]>=nums[l]) j--;
        while(i<j && nums[i]<=nums[l]) i++;
        swap(nums[i],nums[j]);
    }
    swap(nums[l],nums[i]);
    return i;
}

void quicksort(vector<int>& nums, int l, int r)
{
    //子数组长度为1终止递归
    if (l>=r) return;
    //哨兵划分
    int i = partition(nums,l,r);
    //递归左右数组执行哨兵划分
    quicksort(nums,l,i-1);
    quicksort(nums,i+1,l);
}
```


### 1.2非递归解法

非递归解法，用栈或队列实现深度优先或广度优先

```C++
#include<stack>

int partition(vector<int>& nums, int l, int r)
{
    int i=l, j=r;
    while(i<j)
    {
        while(i<j && nums[j]>=nums[l]) j--;
        while(i<j && nums[i]<=nums[l]) i++;
        swap(nums[i],nums[j]);
    }
    swap(nums[i],nums[l]);
    return i;
}

void quickSort(vector<int>& nums, int l, int r)
{
    stack<int> sk;
    sk.push(l); 
    sk.push(r); //有边界后入先出
    //栈为空时代表有序
    while(!sk.empty())
    {
        int right = sk.top();
        sk.pop();
        int left = sk.top();
        sk.pop();

        int i = partition(nums,left,right);

        //对划分的左右区间进行压栈
        //数组区间大小大于1才进行排序
        if (i-left>=2)
        {
            sk.push(left);
            sk.push(i-1);
        }
        if (right-i>=2)
        {
            sk.push(i+1);
            sk.push(right);
        }
    }
}
```



```C++
#include<queue>

int partition(vector<int>& nums, int l, int r)
{
    int i=l, j=r;
    while(i<j)
    {
        while(i<j && nums[j]>=nums[l]) j--;
        while(i<j && nums[i]<=nums[l]) i++;
        swap(nums[i],nums[j]);
    }
    swap(nums[i],nums[l]);
    return i;
}

void quickSort(vector<int>& nums, int l, int r)
{
    queue<int> qs;
    qs.push(r);
    qs.push(l);
    //队列为空代表有序
    while(!qs.empty())
    {
        int right = qs.front();
        qs.pop();
        int left = qs.front();
        qs.pop();

        int i=partition(nums,left,right);

        if (right-i>=2)
        {
            qs.push(right);
            qs.push(i+1);
        }
        if (i-left>=2)
        {
            qs.push(i-1);
            qs.push(left);
        }
    }
}
```

### 1.3练习题

#### 215.最大第k个数(快速选择)

题目描述：
在一个未排序的数组中，找到第 k 大的数字。

Input: [3,2,1,5,6,4] and k =2;
out: 5;

分析：**快速选择**一般用于求解k-th element问题 ，可在O(n)时间复杂度，O(1)空间复杂度求解；
**快速选择**与**快速排序**相似，不过通过哨兵划分找到第k大的枢即可，不需要再对其左右排序

```C++

int partition(vector<int> &nums, int l, int r)
{
    int i, j = l, r;
    while(i<j)
    {
        while(i<j && nums[j]>=nums[l]) j--;
        while(i<j && nums[i]<=nums[l]) i++;
        swap(nums[i],nums[j]);
    }
    swap(nums[i],nums[l]);
    return i;
}

int quickfind(vector<int>& nums, int l, int r,int k)
{
    int targrt = nums.size()-k;
    while(l<r)
    {
        int i = partition(nums,l,r);
        if (target == i)
        {
            return nums[i];
        }
        else if(target > i)
        {
            l = i+1;
        }
        else
        {
            r = i-1;
        }
    }
    return nums[l];
}
```

```c++
//方法2:堆(前k大)

#include <queue>
int quickfing(vector<int>& nums, int k)
{
    if(k > nums.size()) return -1;
    priority_queue<int, vector<int>, greater<int>> pq;

    for(int i=0; i<k; i++)
    {
        pq.push(nums[i]);
    }
    for(int i=k; i<k.size(); i++)
    {
        if(nums[i]>pq.top())
        {
            pq.pop();
            qp.push(nums[i]);
        }
        else
        {
            continue
        }
    }

    return pq.top();
    
}



```

## 桶排序

**桶排序**就是为每个值设置一个桶，桶内记录这个值出现的次数（或其他属性），然后对桶进行排序
每个值对于的桶可以用键-值来实现，键代表数组中不同元素,值代表桶；



### 347. TOP k frequent elements
题目描述：给定一个数组，求前 k 个最频繁的数字。
input: nums = [1,1,1,1,2,2,3,4] , k=2
output: [1,2]

```C++
#include <unordered_map>
#include <vector>
class Solution
{
public:
    vector<int> topkfrequent(vector<int>& nums, int k)
    {
        unordered_map<int,int> counts;
        for (int num:nums)
        {
            //map索引添加键值对
            counts[num]++;
        }
        vector<pair<int,int>> tmp;
        for (auto it:counts)
        {
            tmp.push_back(pair<int,int>(it.first,it.second));
            //tmp.push_back(it);
        }
        //用哨兵划分加二分查找，查找topk;
        int l =0, r =  tmp.size()-1;
        int target = tmp.size()-k;
        vector<int> res;

        while(l<r)
        {
            int mid = partition(tmp,l,r);
            if (mid == target)
            {
                for(int i=mid; i<tmp.size(); i++)
                {
                    res.push_back(tmp[i].first);
                }
                return res;
            }
            else if (target > mid)
            {
                l = mid +1;
            }
            else
            {
                r = mid-1;
            }
        }

        for (int i=l; i<tmp.size(); i++)
        {
            res.push_back(tmp[i].first);
        }
        return res;

    }

    int partition(vector<pair<int,int>>& nums, int l, int r)
    {
        int i=l, j = r;
        while(i<j)
        {
            while(i<j && nums[j].second >= nums[l].second) j--;
            while(i<j && nums[i].second <= nums[l].second) i++;
            swap(nums[i], nums[j]);
        }
        swap(nums[i],nums[l]);

        return i;
    }
}
```


```c++

#include <iostream>
using namespace std;

#include <queue>
#include <unordered_map>

//小顶堆，降序
struct cmp {
    bool operator()(const pair<int,int> &a, const pair<int,int> &b) {
        return a.second < b.second;
    }
};

class Solution
{
public:
  
    vector<int> topkfrequent(vector<int>& nums, int k)
    {
        unordered_map<int, int> mp;
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp > pq;
        vector<int> res;
        for(auto num:nums)
        {
            mp[num]++;
        }

        for(auto it:mp)
        {
            pq.push(it);
        }

        while(k--)
        {
            res.push_back(pq.top().first);
            pq.pop();
        }
        return res;

    }

};

```

### 451.根据字符出现的频率排序

题目描述：

给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。
返回 已排序的字符串?。如果有多个答案，返回其中任何一个。
imput: s = "tree";
output: "eert"或"eetr"


```C++
#include <map>
#include <vector>

class Solution
{
public:
    //根据键值对的值 降序排序
    //加static的原因是,非静态成员函数，参数列表会自动绑定this指针，而sort的函数只有两个参数
    static bool cmp(pair<char,int> a, pair<char, int> b)
    {
        return a.second>b.second;
    }
    string frequencysort(string s)
    {
        map<char int> hash;
        for (int i=0; i<s.size(); i++)
        {
            hash[s[i]]++;
        }

        vector<pair<char,int>> tmp;
        for(auto it:hash)
        {
            tmp.push_back(pair<char,int>(it.first,it.second));
        }
        sort(tmp.begin(),tmp.end(),cmp);

        string res;

        for (auto it:tmp)
        {
            for(int j=0; j<it.second;j++)
            {
                res+=it.first;
            }
        }
        return res;

    }
}
```



## 2.冒泡排序

```C++

void bubblesort(vector<int>& nums)
{
    int n= nums.size();
    for(int i=0; i<n-1; i++)
    {
        for(int j=0; j<n-1-i; j++)
        {
            //每轮内循环比较相邻两数，将最大数移至末尾
            if(nums[j]>nums[j+1])
            {
                swap(nums[j],nums[j+1]);
            }
        }
    }
}

```

## 归并排序

nlogn
```c++

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {

        int l=0, r = nums.size()-1;
        vector<int> temp(nums.size());
        merge_sort(nums, l, r, temp);
        return temp;

    }

    void merge_sort(vector<int>& nums, int l, int r, vector<int>& temp)
    {
        //递归到一个元素，即地递归出口
        if(l >= r) return;

        int m = (l + r) / 2;
        //先分治
        merge_sort(nums,l, m,temp);
        merge_sort(nums,m+1, r,temp);

        //再合并
        //指针分别指向左右数组首部；
        int i=l, j=m+1, pos=l;
        //遍历合并左右子数组
        while(i <= m && j <= r)
        {
            if(nums[i] <= nums[j])
            {
                temp[pos] = nums[i];
                i++;
            }
            else
            {
                temp[pos] = nums[j];
                j++;
            }
            pos++;
        }
        //如果左数组未合并完，则添加剩余元素；
        for(int k=i; k<=m; k++)
        {
            temp[pos++] = nums[k];
        }
        for (int k = j; k <= r; ++k) {
            temp[pos++] = nums[k];
        }
        //把排序好的同步到nums数组
        copy(temp.begin() + l, temp.begin() + r + 1, nums.begin() + l);

    }
};

```

## 堆排序

堆排序是基于堆数据结构设计的一种排序方法，堆是一个近似完全二叉树结构，并满足性质子节点大于或小于父节点

先在原先数组的基础上构造大根堆，时间复杂度nlogn

```c++
class solution
{
public:
    vector<int> sorrarray(vector<int>& nums)
    {
        int n=nums.size();

        //建立大顶堆；
        buildmaxheap(nums, n);

        for(int i=n-1; i>=1; i++)
        {
            //一次交换堆顶元素和堆尾元素，并将当前排序数组减一
            swap(nums[0], nums[i]);
            n--;
            shiftdown(nums,0,n);
        }
        return nums;
    }

    void buildmaxheap(vector<int>& nums, int n)
    {
        //从最后一个叶子结点开始向前遍历
        for(int i=(n-1)/2; i>=0; i++)
        {
            shiftdown(nums, i, n);
        }
    }
    void shifdown(vector<int>& nums, int i, int n)
    {
        while(2*i+1 < n)
        {
            int l = 2*i+1;
            int r = 2*i+2;
            int max = i;
            if(l < n && nums[l] > nums[i]) max = l;
            if(r < n && nums[r] > nums[max]) max = r;

            if(max != i)
            {
                swap(nums[i], nums[max]);
                //迭代判断对应子节点及其儿子节点的大小关系
                i = max;
            }
            else
            {
                break;
            }
        }
    }
}

```




# 查找算法

## 1.二分查找

二分查找要求输入数组为有序数组


### 1.1递归解法

```C++

int binarysearch(vector<int> nums, int l, int r, int target)
{
    if (nums.size()==0 || l>r)
    {
        return -1;
    }
    else
    {
        int mid = (l+r)/2;
        if (nums[mid]==target)
        {
            return mid;
        }
        else if(nums[mid]>target)
        {
            return binarysearch(nums,l,mid-1,target);
        }
        else
        {
            return binarysearch(nums,mid+1,r,target);
        }
    }
}
```


### 1.2非递归解法

```C++

int binarysearch(vector<int> nums, int target)
{
    int l=0, r=nums.size()-1;
    int mid;
    while(l<=r)
    {
        mid = (l+r)/2;
        if (nums[mid]==target)
        {
            return mid;
        }
        else if(nums[mid] > target)
        {
            r = mid-1;
        }
        else
        {
            l = mid+1;
        }
    }
    return -1;


}
```


### 1.3练习题


#### 1.搜索旋转数组(33)


题目描述：给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。


示列：
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

分析：**有序数组的旋转数组局部有序**，即区间[r,mid-1],[mid,l]至少有一个区间有序，
二分思路为，mid为目标值直接返回，判断左右边界时应分类讨论(左有序or右有序)

```C++
class Solution
{
public:
    int search(vector<int>nums, int target)
    {
        int l=0, r= nums.size()-1;
        int mid;
        while(l<=r)
        {
            mid = (l+r)/2;
            if(nums[mid]==target)
            {
                return mid;
            }

            //如果左区间为有序数组
            if(nums[l]<=nums[mid])
            {
                if(target < nums[mid] && target>=nums[l])
                {
                    r = mid-1;
                }
                else
                {
                    l = mid+1;
                }
            }
            //如果右区间为有序数组
            else
            {
                if(target > nums[mid] && target <=nums[r])
                {
                    l = mid+1;
                }
                else
                {
                    r=mid-1;
                }
            }

        }
        return -1;
    }
}

```

# 搜索与回溯算法

## 1.深度优先搜索(dfs)

**深度优先搜索和广度优先搜索**是两种最常见的优先搜索方法，它们被广泛地运用在**图和树**等数据结构

     1
    / \
   2   3                                                     
   /
  4
假如用递归实现该树的深度优先：1->2->4->2(无子节点，返回父节点)->1(子节点已完成遍历，返回父节点)->3->1(无子节点返回父节点)；
使用栈实现，栈顶元素:1->2->4->3;

### 1.1深度优先搜索之数组

#### 岛屿最大面积(695)

题目描述:
输入是一个二维数组，输出是一个整数，表示最大的岛屿面积
Input:
[[1,0,1,1,0,1,0,1],
[1,0,1,1,0,1,1,1],
[0,0,0,0,0,0,0,1]]
Output: 6


```C++
class Solution
{
public:
    int maxarea(vector<vector<int>>& grid)
    {
        int res=0;
        for (int i=0; i<grid.size(); i++)
        {
            for(int j=0; j<grid[0].size();j++)
            {
                res = max(res, dfs(grid,i,j));
            }
        }
    }

    int dfs(vector<vector<int>>& grid, int i, int j)
    {
        if (i<0 || j<0 || i==grid.size() || j==grid[0].size() || grid[i][j]==0)
        {
            return 0;
        }
        int res = 1;
        grid[i][j]=0; //搜索过的标记为0,防止下次再搜索 ********
        res+=dfs(grid, i-1,j); //上
        res+=dfs(grid, i+1,j); //下
        res+=dfs(grid, i,j-1);  //左
        res+=dfs(grid,i,j+1); //右

        return res;
    }
}

```

#### 机器人的运动范围(剑指offer13)

题目描述：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也**不能进入行坐标和列坐标的数位之和大于k的格子**。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

输入：m = 2, n = 3, k = 1
输出：3
输入：m = 3, n = 1, k = 0
输出：1

```C++
#include <vector>

class Solution
{
public:
    int movearea(int m, int m, int k)
    {
        vector<vector<int>> record(m,vector<int>(n,0));  //此处的vector初始化需熟练
        return dfs(0,0,m,n,k,record);
    }

    int dfs(int i, int k, int m, int n, int k, vector<vector<int>>& record)
    {
        if(i<0 || j<0> || i==m || j==m || (i/10 +i%10 +j/10 +j%10)>k || record[i][j])
        {
            return 0;
        }
        int res=1;
        record[i][j]=1; //搜索过的位置做记录，防止下次再搜素;
        res += dfs(i-1,j,m,n,k,record);
        res += dfs(i+1,j,m,n,k,record);
        res += dfs(i,j-1,m,n,k,record);
        res += dfs(i,j+1,m,n,k,record);

        return res;

    }
}
```


## 2.广度优先搜索(bfs)

### 2.1深度优先和广度优先对比

1.深度优先遍历DFS解决的是连通性的问题，即给定两个点，一个是起始点，一个是终止点，判断是不是有一条路径从起点到
终点（这里的起点和终点也可以指起始状态和最终状态）。问题的要求并不在乎是长还是短，只在乎有没有，
有时候题目也会要求把找到的路径完整的打印出来

2.广度优先遍历BFS一般用来解决最短路径的问题。和深度优先搜索不同，广度优先的搜索是从起始点出发，一层一层地进行，
每层当中的点距离起始点的步数都是相同的，当找到了目的地之后就可以立即结束。广度优先的搜索可以同时从起始点和终点
开始进行，称之为双端 BFS。这种算法往往可以大大地提高搜索的效率。



### 最短的桥(934)

题目描述：
在给定的二维二进制数组?A?中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）
现在，我们可以将?0?变为?1，以使两座岛连接起来，变成一座岛。
返回必须翻转的?0 的最小数目。（可以保证答案至少是 1 。）

input：
[[1,1,1,1,1],
 [1,0,0,0,1],
 [1,0,1,0,1],
 [1,0,0,0,1],
 [1,1,1,1,1]]

output:1

input:
[
    [0,1,0,0],
    [0,0,0,0],
    [0,0,0,1]
]
output:3

```C++

#include <queue>
class Solution
{
public:
    int shortestBrudge(vector<vector<int>>& grid)
    {
        vector<int> x_direction{-1, 0, 1, 0};
        vector<int> y_direction{ 0, 1, 0,-1};
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> points;
        //dfs寻找第一个岛屿，并把1赋值为2，并记录所有岛屿起始位置，作为bfs的搜索起点
        bool flag = false;  //找到一个岛屿就停止搜索
        for(int i=0; i<m; i++)
        {
            if(flag)
            {
                break;
            }
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1)
                {
                    dfs(points, grid, m, n, i, j);
                    falg = true;
                    break;
                }
            }
        }

        //bfs寻找通往第二个岛屿的路径，并把经过的0赋值为2
        int x, y;
        int level=0;
        while(!points.empty())
        {
            level++;
            int width = points.size();
            for(int i=0;  i<width; i++)
            {
                auto [r, c] = points.front();
                points.pop();
                for(int k=0; k<4; k++)
                {
                    x = r + x_direction[k], y = c + y_direction[k];
                    if(x >= 0 && y >= 0 && x <m && y < n && grid[x][y] != 2)
                    {
                        if (grid[x][y]==1)
                        {
                            return level;
                        }
                        points.push({x,y});
                        grid[x][y] = 2;
                    }
                }
            }
        }
        return 0;
    }

    void dfs(queue<pair<int,int>>& points, vector<vector<int>>& grid, int m, int n, int i, int j)
    {
        if(i<0 || j < 0 || i==m || j==n || grid[i][j]==2)
        {
            return;
        }
        if(grid[i][j] == 0)
        {
            points.push({i,j});
            return;
        }

        grid[i][j]=2;
        dfs(points, grid, m, n, i-1, j);
        dfs(points, grid, m, n, i+1, j);
        dfs(points, grid, m, n, i, j-1);
        dfs(points, grid, m, n, i, j+1);

    }
}

```

### 01 Matrix(542)

题目描述：
给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。

Input:
[[0,0,0]，
[0,1,0],
[1,1,1]]
Output:
[[0,0,0],
[0,1,0],
[1,2,1]]



```c++
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) 
    {
        int m = mat.size();
        int n = mat[0].size();

        queue<pair<int,int>> q;
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(mat[i][j] == 0)
                {
                    q.push({i,j});
                }
                else
                {
                    mat[i][j] = -1;   //把未搜索过的都标记为-1；
                }
            }
        }

        int level = 0;
        int x, y;
        int x_derection[-1,0,1,0];
        int y_derection[0,-1,0,1];

        while(!q.empty())
        {
            level++;
            int width = q.size();

            for(int i=0; i< width; i++)
            {
                auto [r,c] = q.front();
                q.pop();

                for(int k=0; k<4; k++)
                {
                    x = r + x_derection[k];
                    y = c + y_derection[k];

                    if(x>0 && y>0 && x<m && y<m && mat[i][j]==-1)
                    {
                        mat[i][j] = level;
                        q.push({x,y});
                    }
                }
            }
        }
    }

}
```





## 3.回溯法

**回溯法是优先搜索的一种特殊情况，又称试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排序，组合，选择类问题使用回溯法更加方便。**

回溯法与动态规划的区别
共同点：
用于求解多阶段决策问题即：
1.求解一个问题分成很多阶段；
2.每个阶段可以有很多选择；
不同点：
1.动态规划只需要求最优解，最优解对应的具体解不要求。因此很适合应用于评估一个方案的效果；
2.回溯算法可以搜索得到所有方案(包括最优解)，但它本质是一种遍历算法，时间复杂度很高。

### 2.1排列、组合、子集相关问题(一维数组)

#### 2.1.1全排列(46)


题目描述：
给定一个无重复数字的数组，求其所有的排方式。
Input: [1,2,3]
Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1], [3,1,2]]

```C++

class Solition
{
public:

    void dfs(vector<int>& nums, int level, int l, vector<vector<int>>& res; vector<bool>& record, vector<int>& path)
    {
        //递归出口；
        if(level==l)
        {
            res.push_back(path);
            return;
        }
        for(int i=0; i<l; i++)
        {
            if(!record[i])
            {
                path.push_back(nums[i]);
                record[i]=true;

                dfs(nums,level+1, l, res, record, path);

                //状态重置
                record[i]=false;
                path.pop_back();
                
            }

        }


        
    }
    vector<vector<int>> permute(vector<int>& nums)
    {
        int l = nums.size();
        vector<bool> record(l,false);  //状态数组记录当前层数
        vector<vector<int>> res;
        vector<int> path; //记录当前路径
        dfs(nums,0,l,res, record, path);
        return res;
    }
}



```


#### 2.1.2组合(77)

题目描述：给定两个整数n和k，返回范围[1,n]中所有可能的k个数的组合。

input: n=4, k=2;
output: [
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
]


```C++

#include <vector>
class Solution
{
public:

    void dfs(int n, int level, int k, vector<int>& path, vector<vector<int>>& res)
    {
        if(path.size()==k)
        {
            res.push_back(path);
            return;
        }
        for(int i=level; i<n; i++)
        {
            path.push_back(i+1);
            
            dfs(n,i+1, k,path,res);   //注意组合是i+1

            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k)
    {
        vector<int> path;
        vector<vector<int>> res;

        dfs(n, 0, k, path, res);
        return res;
    }
}

```

#### 2.1.3 组合之和（39)

题目描述：
给你一个 无重复元素 的整数数组?candidates 和一个目标整数?target?，找出?candidates?中可以使数字和为目标数?target 的 所有?不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。

input:
candidates = [2,3,6,7], target = 7
output:
[[2,2,3],[7]]

input:
candidates = [2,3,5], target = 8
output:
[[2,2,2,2],[2,3,3],[3,5]]


```C++

#include <vector>
class Solution {
public:

    void dfs(vector<int>& candidates,int level, int l,int target, vector<int>& path, vector<vector<int>> &res)
    {
        if(target<0)
        {
            return;
        }
        if(target==0)
        {
            res.push_back(path);
            return;
        }
        for(int i=level;i<l;i++)  //排列和组合的区别i=0/i=level
        {
            path.push_back(candidates[i]);
            target = target-candidates[i];

            dfs(candidates,i,l,target,path,res);

            path.pop_back();
            target = target+candidates[i];
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {

        sort(candidates.begin(),candidates.end());
        int l = candidates.size();
        vector<vector<int>> res;
        vector<int> path;
        dfs(candidates,0,l,target,path,res);
        return res;
    }
};

```


#### 2.1.4子集(78)


题目描述:
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集;
input:
nums = [1,2,3]
output:
[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]



```c++
class Solution {
public:
    void dfs(vector<int>& nums, int level, int k, vector<int>& path, vector<vector<int>>& res)
    {
        res.push_back(path);
        if(level==k)    //子集的递归出口，当前i==nums.size(),i表示当前数组的索引位置，索引到末尾即退出
        {
            return;
        }
        for(int i=level; i<k; i++)
        {
            path.push_back(nums[i]);
            
            dfs(nums,i+1,k,path,res);

            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> path;
        int k = nums.size();
        dfs(nums,0,k,path,res);
        return res;

    }
};


```

#### 2.1.5复原ip地址

题目描述：
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。

给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入?'.' 来形成。你 不能?重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

```C++

class Solution {
public:
    vector<string> restoreIpAddresses(string s) 
    {

        vector<string> res;
        string path;
        int n = s.size();
        // if(n < 4) return {};
        dfs(s, 0, 0, n, path, res);
        return res;
    }
    //index表示每段数字的起始索引,注意path没有用引用；
    void dfs(string& s, int index, int level, int& n, string path, vector<string>& res)
    {
        if(level == 4)
        {
            res.push_back(path);
            return;
        }
        if(level != 0) path.push_back('.');

        for(int len=1; len<=3; len++)
        {
            if(n-index-len > (3-level)*3) //剩余字符过多，剪枝；
            {
                continue;
            }
            if (n-index-len < 0) { // 没考虑这个情况，剩余字符不够了，也剪枝，条件可以直接加到上面
                continue;
            }
            if(len > 1 && s[index]=='0') // len为2、3时首位零则是非法前导零，直接终止
            {
                return;
            }
            if(stoi(s.substr(index, len)) > 255)
            {
                return;
            }

            for(int i=0; i<len; i++)
            {
                path.push_back(s[index+i]);
            }

            dfs(s, index+len, level+1, n, path, res);

            for(int i=0; i<len; i++)
            {
                path.pop_back();
            }
        }

    }

};
```



### 2.2 字符串回溯


#### 2.2.1电话号码的字母组合(17)(排列)

题目描述:
给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合，答案可以按任意顺序返回(组合问题)

2:abc, 3:def, 4:ghi, 5:jkl, 6:mno, 7:pqrs, 8:tuv, 9:wxyz;

input: "23";
output: ["ad","ae","af","bd","be","bf","cd","ce","cf"];

input = "";
output  = [];

                                     []
            [a]                      [b]
[a,d]      [a,e]    [a,f]        [b,d], [b,e] [b.f]

```C++
class solution
{
public:
    vector<string> lettercomine(string digits)
    {
        map<int,string> mp;

        initial(mp);

        vector<string> res;
        string path;

        vector<string> nums;
        
        convert_num(digits, mp, nums);

        dfs(nums, 0, nums.size(), path, res);
        return res;
    }
    
    void convert_num(string digits, map<int,string>& mp, vector<string>& nums)
    {
        for(auto c : digits)
        {
            int index = c - '0';
            nums.push_back(mp[index]);
        }
    }

    void dfs(vector<string>& nums, int level, int l, string& path, vector<string>& res)
    {
        if(path.size() == l)
        {
            res.push_back(path);
            return;
        }

        for(int i=0; i<nums[level].size(); i++)
        {
            path.push_back(nums[level][i]);

            dfs(nums, level+1, l, path, res);

            path.pop_back();
        }
    }
     void initial(map<int,string>& mp)
    {
        mp.insert(pair<int,string>(2,"abc"));
        mp.insert(pair<int,string>(3,"def"));
        mp.insert(pair<int,string>(4,"ghi"));
        mp.insert(pair<int,string>(5,"jkl"));
        mp.insert(pair<int,string>(6,"mno"));
        mp.insert(pair<int,string>(7,"pqrs"));
        mp.insert(pair<int,string>(8,"tuv"));
        mp.insert(pair<int,string>(9,"wxyz"));
    }
};

```


#### 2.2.2字母大小写全排列(784)(子集)

题目描述：
给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。
返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。
input:
s = 'a1b2';
output:
["a1b2", "a1B2", "A1b2", "A1B2"]

```C++

class solution
{
public:
    vector<string> lettercasepermutation(string s)
    {
        vector<int> zimu;
        for(int i=0; i<s.size();i++)
        {
            if((s[i]>'a' && s[i]<='z') ||(s[i]>='A' && s[i]<='Z'))
            {
                zimu.push_back(i);
            }
        }

        int l = zimu.size();
        vector<int> path;
        vector<vector<int>> res1;
        dfs(zimu,0,l,path,res1);
        vector<string> res;
        convert(res1,res,s);
        return res;

    }
    void convert(vector<vector<int>>& res1, vecotr<string>& res,string s)
    {
        string temp=s;
        for(auto it:res1)
        {
            if(it.empty())
            {
                res.push_back(s);
                continue;
            }
            else
            {
                for(auto i:it)
                {
                    convert1(temp,i);
                }
                res.push_back(temp);
                temp=s;
            }
        }
    }
    void convert1(string& temp, int i)
    {
        if(temp[i]>'a' && temp[i]<'z')
        {
            char c = temp[i]-32;
            string s(1,c);
            temp.replace(i,1,s);
        }
        else
        {
            char c = temp[i]+32;
            string s(1,c);
            temp.replace(i,1,s);
        }
    }

    void dfs(vector<int> zimu, int level, int l, vector<int>& path, vector<vector<int>>& res1)
    {
        res1.push_back(path);
        if(path.size()==l)
        {
            return;
        }
        for(int i=level; i<l; i++)
        {
            path.push_back(zimu[i]);

            dfs(zimu,i+1,l,path,res);

            path.pop_back();
        }
    }
}

```



#### 2.2.3 单词拆分2(140)

给定一个字符串 s 和一个字符串字典?wordDict?，在字符串?s?中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。

输入:s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
输出:["cats and dog","cat sand dog"]

```c++

class solution
{
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) 
    {
        vector<vector<string>> res;
        vector<string> path;
        //利用set快速查询
        set<string> wordset;
        for(auto it:wordDict)
        {
            wordset.insert(it);
        }
        dfs(s, 0, path, res, wordset);
        vector<string> res1;
        convert(res, res1);
    }

    void convert(vector<vector<string>> res, vector<string>& res1)
    {
        for(auto it : res)
        {
            string temp;
            for(auto str: it)
            {
                temp += str;
                temp += ' ';
            }
            temp = temp.substr(0, temp.size()-1);
            res1.push_back(temp);
        }
    }

    void dfs(string s, int level, vector<string>& path, vector<vector<string>>& res, set<string>& wordset)
    {
        if(level == s.size())
        {
            res.push_back(path);
            return;
        }

        for(int i=level; i<s.size(); i++)
        {
            string word = s.substr(level, i+1-level);
            if(wordset.find(word) == wordset.end())
            {
                continue;
            }
            path.push_back(word);

            dfs(s, i+1, path, res, wordset);

            path.pop_back();
        }


    }
};
```



#### 2.2.4 单词拆分（139)(记忆化搜索)

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true

```C++
#include <vector>
class solution
{
public:
    bool wordBreak(string s, vector<string>& wordDict)
    {
        vector<vector<string>> res;
        vector<string> path;
        set<string> wordset;

        for(auto it : wordset)
        {
            wordset.insert(it);
        }
        int n = s.size();
        vector<int> record(n, 0);
        return dfs(s, 0, path, res, wordset, record);
    }

    bool dfs(string s, int level, vector<string>& path, vector<vector<string>>& res, set<string>& wordset, vector<int>& record)
    {
        if(level == s.size())
        {
            return true;
        }
        //如果子问题已经处理过，直接返回结果(剪枝)
        if(record[level] == 1)
        {
            return true;
        }
        //如果子问题已经处理过，直接返回结果(剪枝)
        else if(record[level] ==-1)
        {
            return false;
        }
        for(int i=level; i < s.size(); i++)
        {
            string word = s.substr(level, i+1-level);
            if(wordset.find(word) == wordset.end())
            {
                continue;
            }

            path.push_back(word);

            bool subres = dfs(s, i+1, path, res, worddict,record);

            path.pop_back();

            if(subres)
            {
                //说明[level...n-1]是可拆分的，记录状态；
                record[level] = 1;
                return true;//dfs函数 true出口;
            }

        }

        // 已经完整遍历 [start...n-1] 都无法拆分
        record[level] = -1;
        return false;
    }
};



```




### 2.3二维数组 

#### 2.3.1图像渲染(733)

有一幅以?m x n?的二维整数数组表示的图画?image?，其中?image[i][j]?表示该图画的像素值大小。

你也被给予三个整数 sr ,? sc 和 newColor 。你应该从像素?image[sr][sc]?开始对图像进行 上色填充 。

为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为?newColor?。

最后返回 经过上色渲染后的图像?。
input:
[
    [1,1,1],
    [1,1,0],
    [1,0,1],
]
sr=1,sc=1,newcolor=2;
output:
[
    [2,2,2],
    [2,2,0],
    [2,0,1],
]

```C++

class solution
{
public:
    vector<vector<int>> floodfill(vector<vector<int>>& image, int sr, int sc,int newcolor)
    {
        int color = image[sr][sc];
        int m = image.size();
        int n = image[0].size();
        vector<vector<int>> record(m,vector<int>(n,0));
        dfs(image,sr,sc,color,newcolor,record);
        return image;
    }

    void dfs(ector<vector<int>>& image, int i, int j,int color,int newcolor,vector<vector<int>>& record)
    {
        if(i<0 || j<0 || i==image.size() || j==image[0].size() || image[i][j]!=color || 
        record[i][j]==1)
        {
            return;
        }

        image[i][j]=newcolor;
        record[i][j]=1;
        dfs(image,i-1,j,color,newColor,record);
        dfs(image,i+1,j,color,newColor,record);
        dfs(image,i,j-1,color,newColor,record);
        dfs(image,i,j+1,color,newColor,record);
    }
}


```


#### 2.3.2岛屿数量(200)
input:
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

input:
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3

```c++
#include <vector>
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) 
    {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> record(m, vector<int>(n, 0));
        int k=0;
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j]=='1' && record[i][j]==0)
                {
                    dfs(grid, i, j, record);
                    k++;
                }
            }
        }
        return k;
    }

    void dfs(vector<vector<char>>& grid, int i, int j, vector<vector<int>>& record)
    {
        if(i<0 || j<0 || i==grid.size() || j==grid[0].size() || record[i][j] || grid[i][j] != '1')
        {
            return;
        }
        record[i][j]=1;
        dfs(grid, i+1, j, record);
        dfs(grid, i-1, j, record);
        dfs(grid, i, j+1, record);
        dfs(grid, i, j-1, record);
    }
};


```

#### 2.3.3单词搜索

题目描述：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
input:
board = [["A","B","C","E"],
         ["S","F","C","S"],
         ["A","D","E","E"]]
worrd = "ABCCED"
output:true;

```c++
class solution
{
public:
    bool exit(vecot<vector<char>>& board,string word)
    {
        int m=board.size();
        int n=board[0].size();
        vector<vector<int>> record(m,vector<int>(n,0));
        bool find=false;
        for(int i=0;i<board.size();i++)
        {
            for(int j=0;j<board[0].size();j++)
            {
                dfs(board,i,j,word,0,find,record);
            }
        }
        return find;
    }
    void dfs(vector<vector<char>>& board, int i, int j, string word,int l, bool& find, vector<vector<int>>& record)
    {
        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || board[i][j]!=word[l] || record[i][j]==1 || find)
        {
            return;
        }
        if(l==word.size()-1)
        {
            find=true;
            return;
        }
        record[i][j]=1; //此record是为了避免同一条路径往回走，所以需要回溯状态；
        l+=1;
        dfs(board,i-1,j,word,l,find,record);
        dfs(board,i+1,j,word,l,find,record);
        dfs(board,i,j-1,word,l,find,record);
        dfs(board,i,j+1,word,l,find,record);
        recrod[i][j]=0;
    }
}
```

#### 2.3.4 N皇后(51)(全排列)

题目描述：
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
n?皇后问题 研究的是如何将 n?个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的?n?皇后问题 的解决方案。
每一种解法包含一个不同的?n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
input:4
output:
[
   [".Q..","...Q","Q...","..Q."],
   ["..Q.","Q...","...Q",".Q.."]
]


思路:矩阵坐标元素不共线，在同一条斜率为正的直线i+j相等，在同一条斜率为负的直线横纵坐标差相等;

```C++
#include <vector>
class solution
{
public:
    vector<vector<string>> solveNQueens(int n)
    {
        vector<pair<int,int>> path;
        vector<vector<pair<int,int>>> res1;
        for(int j=0; j<n ;j++)
        {
            dfs(n,0,j,path,res1);
        }
    }
    void dfs(int n,int i,int j, vector<pair<int,int>>& path, vector<vector<pair<int,int>>>& res)
    {
        if(path.size()==n && j==0)
        {
            res.push_back(path);
            return;
        }
        if(i==n || j==n)
        {
            return;
        }
        if(i>0)
        {
            for(auto it:path)
            {
                if(it.second==j || i+j==it.first+it.second || j-i==it.second-it.first)
                {
                    return;
                }
            }
        }
        path.push_back(pair<int,int>(i,j));
        for(int l=0; l<n;l++)
        {
            dfs(n,i+1,l,path,res);
        }
        path.pop_back();
    }
}
```


## 4.记忆化搜索


### 4.1 不同子序列

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE"?是?"ABCDE"?的一个子序列，而?"AEC"?不是）

输入：s = "rabbbit", t = "rabbit"
输出：3

输入：s = "babgbag", t = "bag"
输出：5

```c++
//带记忆优化 超时?
class Solution {
public:
    map<pair<int,int>, int> mp;
    int numDistinct(string s, string t) {

        return dfs(s,t,0,0);

    }
    int dfs(string s, string t, int i, int j)
    {
       if(mp.find({i,j}) != mp.end())
       {
           return mp[{i,j}];
       }
        //先判断t是否匹配完
        if(j == t.size()) return 1;
        if(i == s.size()) return 0;

        int cnt = 0;

        cnt += dfs(s,t,i+1, j);

        if(s[i]==t[j])
        {
            cnt += dfs(s,t,i+1, j+1);
        }
        mp[{i,j}] = cnt;
        return cnt;
    }
};
```
```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        mp = {}     # 记忆化单元【哈希表存储】

        def dfs(i, j):
            if (i, j) in mp:    # 以前搜索过该位置
                return mp[(i,j)]

            if j == len(t):     # t匹配完了
                return 1
            if i == len(s):     # s匹配完了依然没找到答案
                return 0
            
            cnt = 0
            
            # 跳过s[i]，并进行下一步搜索：s[i+1]与t[j]匹配
            cnt += dfs(i+1, j)

            # 选择s[i]，并进行下一步搜索
            if s[i] == t[j]:    # 能选择s[i]的前提条件为：s[i] == t[j]
                cnt += dfs(i+1, j+1)
            
            mp[(i, j)] = cnt    # 记录下 (i,j) 的结果，以备后续直接使用
            return cnt
        
        return dfs(0, 0)        # 初始从s[0]和t[0]开始搜索

```
# 双指针

## 1.快慢指针

### 1.1 链表第k个节点

思路 : [1,2,3,4,5,6,7,8]  -> [1,2,3,4,5,6,7,8]
        s     q                      s      q

```c++

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
 };
 
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {

        ListNode *q = head, *s = head;
        //1.快指针先走k步；
        for(int i=1; i<=k; i++)
        {
            q = q->next;
        }

        while(q)
        {
            q = q->next;
            s = s->next;
        }
        return s;


    }
};

```


## 2.双指针(反向与同向)
若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是
排好序的


### 2.1两数之和(有序数组(反向指针))

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
```c++
vector<int> twoSum(vector<int>& numbers, int target) {

        int l = 0, r = numbers.size()-1;
        vector<int> res;
        while(l<r)
        {
            if(numbers[l] + numbers[r] == target)
            {
                res.push_back(l+1);
                res.push_back(r+1);
                return res;
            }
            else if(numbers[l] + numbers[r] > target)
            {
                r--;
            }
            else
            {
                l++;
            }
        }
        return res;

    }
```


### 2.2 合并两个有序数组(同向指针)
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3

input2: nums1 = [0], m=0, nums2 = [1], n = 1;

input3: nums1 = [3,4,5,0,0], nums[2] = [1,6];

case1:
```c++
 void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        if(m==0)
        {
            nums1 = nums2;
        }
        int p1 = m-1, p2 =n-1, p3 = nums1.size()-1;
        while(p1 >=0 && p2 >= 0)
        {
            if(nums1[p1] <= nums2[p2])
            {
                nums1[p3] = nums2[p2];
                p3--;
                p2--;
            }
            else
            {
                nums1[p3] = nums1[p1];
                p1--;
                p3--;
            }
        }
        while(p2>=0)
        {
            nums1[p3] = nums2[p2];
            p2--;
            p3--;
        }
        return;

    }

```

## 2.3通过删除字母匹配到字典最长单词(双指针之子序列问题)


题目：给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。
给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。

输入：s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
输出："apple"


输入：s = "abpcplea", dictionary = ["ale","bpple","apple","monkey","plea"]
输出："apple"
```c++

class Solution {
public:
    string findLongestWord(string s, vector<string>& dictionary) {

        string res = "";

        for(auto dic : dictionary)
        {
            int l = 0, r = 0;
            while(l < s.size() && r < dic.size())
            {
                //如果s[l] = dic[r], 则指针l,r右移，否则只移动l++；
                if(s[l] == dic[r])
                {
                    r++;
                }
                l++;
                //如果单词指针到达末尾+1说明为子序列
                if(r == dic.size())
                {
                    if(r > res.size())
                    {
                        res = dic;
                    }
                    //字符串大小比较按照第一个字母的ASCLL码
                    else if(r == res.size() && dic < res)
                    {
                        res = dic;
                    }
                }
            }
        }
        return res;





    }
};

```

## 3.滑动窗口

若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的
区域即为当前的窗口），经常用于区间搜索。


### 3.1最小覆盖串(76)
题目描述：
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

输入：s = "a", t = "a"
输出："a"

输入: s = "a", t = "aa"
输出: ""

```c++
class Solution {
public:
    string minWindow(string s, string t) {

        unordered_map<char,int> ms;
        unordered_map<char,int> mt;
        int l = 0, r = 0;
        string res;
        int cnt = 0;
        for(auto s:t)
        {
            mt[s]++;
        }
        //每轮r指针向右扩大，l指针降重包括在一轮之内
        for(int r=0; r < s.size(); r++)
        {
            ms[s[r]]++;
            if(ms[s[r]] <= mt[s[r]]) cnt++;
            //收缩滑动窗口;
            while(ms[s[l]] > mt[s[l]])
            {
                ms[s[l]]--;
                l++;
            }

            //
            if(cnt == t.size())
            {
                if(res.empty() || r-l+1 < res.size())
                {
                    res = s.substr(l, r-l+1);
                }
            }
        }
        return res;
        

    }
};

```
# 动态规划

## 1.基本动态(一维)

### 1.1 斐波拉契数列(10)

题目描述：
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

input:n=2;
output:1;

input: n=5;
output: 5;


#### 1.1.1.直接递归

```c++

int fib(int n)
{
    if(n==0) return 0;
    if(n==1) return 1;

    return fib(n-1)+fib(n-2);
}

```

#### 1.1.2 回溯法

```c++
//时间复杂度为递归的次数,次数取决于二叉树的节点,为O(n)
int fib(int n)
{
    return dfs(n);
}


int dfs(int n)
{
    if(n==0) return 0;
    if(n==1) return 1;

    int left = dfs(n-1);
    int right = dfs(n-1);

    return left + right;
}

```

#### 1.1.3 记忆化搜索(带状态记录的优先搜索)

**为了解决重复子问题，在这里体现为重复子节点的搜索，可以用维护一个记录状态的map或数组，用于剪枝**
``` c++

//时间复杂度O(n)
#include <map>
int fib(int n) {
    map<int, int> mp;
    return dfs(n, mp);
}
int dfs(int n, map<int, int>& mp)
{
    if(n==0) return 0;
    if(n==1) return 1;
    //先从map中检索子问题的解，如果有记录直接返回
    if(mp.find(n) != mp.end())
    {
        return mp[n];
    }

    int left = dfs(n-1, mp);
    int right = dfs(n-2, mp);
    //将计算的结果存储到map
    mp.insert({n, (left+right)});

    return mp[n];
}

```

#### 1.1.4动态规划(自底向上)
```C++

//时间复杂度O(n), 空间复杂度O(n)
int fib(int n)
{
    if(n<=0) return n;

    //1.定义状态数组
    vector<int> dp(n+1)

    //2.状态初始化
    dp[0] = 0;
    dp[1] = 1;

    //3.状态转移
    for(int i=2; i<=n; i++)
    {
        dp[i] = dp[i-1] + dp[i-2];
    }

    //4.返回最终的状态值
    return dp[n];
}

```


#### 1.1.5动态规划状态压缩

```C++

//时间复杂度O(n),空间复杂度O(1)

int fib(int n)
{
    if (n<=0) return n;

    //1.定义两个状态变量并初始化   (因为自底向上每一个当前值只需要前面两个状态值计算)
    int prev = 0;
    int cur = 1;

    //2.状态转移
    for(int i=2; i<=n; i++)
    {
        int sum = prev + cur;
        prev = cur;
        cur = sum;
    }

    //3.返回最终结果值
    return cur;
    
}


```


### 1.2跳台阶(70)

题目描述：给定 n 节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。

input:3;
output:3;

分析：因为我们每次可以走一步或者两步，所以第i个台阶可以由i-1或i-2的位置到达，所以到达i的方法数是到达i-1和i-2之和
状态转移方程为dp[i] = dp[i-1] + dp[i-2];
边界条件  dp[1]=1, dp[2]=2;

```C++
int fib(int n)
{
    return dfs(n);
}

int dfs(int n)
{
    if(n==1) return 1;
    if(n==2) return 2;

    int prev = 1;
    int cur = 2;

    for(int i = 3; i <= n; i++)
    {
        int sum = prev + cur;
        prev = cur;
        cur = sum;
    }
    return cur
}

```

### 1.3抢房子(198)

题目描述:
假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果
你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。

输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。

input: [2,7,9,3,1]
output: 12


状态转移方程: dp[i] = max(dp[i-1], dp[i-2] + nums[i-1]) (k);
边界条件 dp[1] = nums[0];
        dp[0] = 0




```c++

#include <vector>

int fib(vector<int>& nums)
{
    if(nums.empty()) return 0;

    //1.定义状态数组
    vector<int> dp(nums.size()+1,0);

    //2.初始化边界状态
    dp[1] = nums[0];
    //dp[0] = 0 定义时已初始化

    //3.状态转移
    for(int i=2; i<= n; i++)
    {   
        dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);
    }

    //4.返回最终值
    return dp[n];

    
}


//状态压缩

int fib(vector<int>& nums)
{
    if(nums.empty()) return 0;
    int n = nums.size();   
    int prev = 0；
    int cur = nums[0];

  


    //状态转移
    for(int i=2; i<= n; i++)
    {   
       int sum = max(cur, prev + nums[i-1]);
       prev = cur;
       cur = sum;
    }

    //4.返回最终值
    return cur; 

    
}



```



## 2.基本动态规划(二维)

### 2.1最优路径(64)

题目描述:
给定一个 m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最
小的路径。每次只能向右或者向下移动。

输入是一个二维数组，输出是最优路径的数字和。
Input:
[[1,3,1],
[1,5,1],
[4,2,1]]
Output: 7

分析: 状态转移方程dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
                dp[i][j] = dp[i][j-1] + grid[i][j] , i==0
                dp[i][j] = dp[i-1][j] + grid[i][j], j==0
    边界条件dp[0][0] = grid[0][0];

```c++
int minpathsum(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n,0));

    for(int i=0; i<m; i++)
    {
        for(int j=0; j<n; j++)
        {
            if(i==0 && j==0)
            {
                dp[i][j] = grid[0][0];
            }
            else if(i==0)
            {
                dp[i][j] = dp[i][j-1] + grid[i][j]
            }
            else if(j==0)
            {
                dp[i][j] = dp[i-1][j] + grid[i][j]
            }
            else
            {
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
    }
    return dp[m][n];
}

```


## 3.分割类型题

### 3.1最短平方和(279)
题目描述:
给定一个正整数，求其最少可以由几个完全平方数相加构成。
Input: n = 13
Output: 2
在这个样例中，13 的最少构成方法为 4+9。


分析:
对于分割类型题，动态规划的状态转移方程**通常不依赖相邻位置**，而依赖于满足分割条件的位置;

拆分：
dp[0] = 0;
dp[1] = 1 + dp[0] = 1;
dp[2] = 1 + min(dp[1]) = 2;
dp[3] = 1 + min(dp[3-1])) = 3;
dp[4] = 1 + min(dp[4-1], dp[4-4]) = 1;
dp[5] = 1 + min(dp[5-1], dp[5-4]) = 2;
dp[10]= 1 + min(dp[10-1], dp[10-4], dp[10-9])

dp[i] = 1 + min(dp[i-1], dp[i-4], dp[i-9], dp[i-k*k])  k*k<=i;


```c++

class Solution {
public:
    int numSquares(int n) {

        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;
        for(int i=1; i<=n; i++)
        {
            for(int j=1; j*j<i; j++)
            {
                dp[i] = min(1 + dp[i-j*j], dp[i]);
            }
        }
        return dp[n];        
        
    }
};



```



### 3.2剪绳子

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

思路
对于的长度为n的绳子，当 n ≥ 2 时，可以剪成至少两个绳子。令 k 是剪出的第一段绳子，则剩下的部分是 n?k，n?k 可以不继续剪，或者继续剪成至少两段绳子（一个问题可以分解为相似的子问题因此想到动态规划）。由于每个绳子长度对应的最大乘积取决于比它小的绳子对应的最大乘积，因此可以使用动态规划求解。

当 i ≥ 2 时，假设对长度为 i 绳子剪出的第一段绳子长度是 j（1≤j<i），则有以下两种方案：
将 i 剪成 j 和 i-j 长度的绳子，且 i?j 不再继续剪，此时的乘积是 j×(i?j) ；
将 i 剪成 j 和 i?j 长度的绳子，且 i?j 继续剪成多段长度的绳子，此时的乘积是 j×dp[i?j] 。
因此，当 j 固定时，有 dp[i]=max(j×(i?j),j×dp[i?j])。由于 j 的取值范围是 1 到 i ，需要遍历所有的 j 得到dp[i]的

```c++
class Solution {
public:
   
    int cuttingRope(int n) {
       
       vector<int> dp(n+1);

       dp[2] = 1;

       for(int i=3; i<=n; i++)
       {
           for(int j=1; j<i; j++)
           {
               dp[i] = max(dp[i],max(j*(i-j), j*dp[i-j]));
           }
       }
       return dp[n];

    }

   
};
```

## 4.子序列问题

对于子序列问题，第一种动态规划方法是，定义一个dp数组，其中dp[i]表示以i结尾的子序列性质

### 4.1 连续子数组最大和
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。


分析：动态转移方程为：dp[i] = max(nums[i], dp[i-1] + nums[i])



```c++

class Solution {
public:
    int maxSubArray(vector<int>& nums) {

        if(nums.size() == 0) return 0;

        int maxnum = nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        for(int i=1; i<nums.size(); i++)
        {
            dp[i] = max(nums[i], dp[i-1] + nums[i]);
            maxnum = max(maxnum, dp[i]);
        }

        return maxnum;
        

    }
};

```


### 4.2 最长递增子序列


输入是一个一维数组，输出是一个正整数，表示最长递增子序列的长度。

Input: [10,9,2,5,3,7,101,18]
Output: 4
在这个样例中，最长递增子序列之一是 [2,3,7,18]。

状态转移方程:dp[i] = max(dp[j] + 1 , dp[i]] (0<=j<i && nums[i] > nums[j])


```c++
class Solution {
    public:
        int lengthOfLIS(vector<int>& nums) {
            if(nums.empty())
            {
                return 0;
            }
            int n = nums.size();

            vector<int> dp(n+1, 0);

            for(int i=1; i<=n; i++)
            {
                dp[i] = 1;  //初始化均为1 
                //0<=j<i && nums[i]>nums[j], 转态转移方程 dp[i] = max(dp[j]) + 1 -> dp[i] = max(dp[j] + 1) (0<=j<i)
                for(int j=1; j<i; j++)
                {
                    if(nums[i-1] > nums[j-1])
                    {
                        dp[i] = max(dp[i], dp[j]+1);
                    }
                }
            }

            return *max_element(dp.begin()+1, dp.end());

        
        }


    };

    
```

# 分治

## 1.排序数组(912)

```c++

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {

        int l=0, r = nums.size()-1;
        vector<int> temp(nums.size());
        merge_sort(nums, l, r, temp);
        return temp;

    }

    void merge_sort(vector<int>& nums, int l, int r, vector<int>& temp)
    {
        //递归到一个元素，即地递归出口
        if(l >= r) return;

        int m = (l + r) / 2;
        //先分治
        merge_sort(nums,l, m,temp);
        merge_sort(nums,m+1, r,temp);

        //再合并
        //指针分别指向左右数组首部；
        int i=l, j=m+1, pos=l;
        //遍历合并左右子数组
        while(i <= m && j <= r)
        {
            if(nums[i] <= nums[j])
            {
                temp[pos] = nums[i];
                i++;
            }
            else
            {
                temp[pos] = nums[j];
                j++;
            }
            pos++;
        }
        //如果左数组未合并完，则添加剩余元素；
        for(int k=i; k<=m; k++)
        {
            temp[pos++] = nums[k];
        }
          for (int k = j; k <= r; ++k) {
            temp[pos++] = nums[k];
        }
        //把排序好的同步到nums数组
        copy(temp.begin() + l, temp.begin() + r + 1, nums.begin() + l);

    }
};
```

## 1.1 数组中的逆序对

题目描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

 输入: [7,5,6,4]
输出: 5

分析：逆序对和归并的关系
L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8, 9]
        |                          |
       lPtr                       rPtr

此时lptr比rptr小，但比mid+1-rptr大，lptr跟右子数组可以组成rptr-(mid+1)个逆数组


```c++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n-1;
        vector<int> temp(n);
        return merge_sort(nums,temp,l,r);

    }
    int merge_sort(vector<int>&nums, vector<int>&temp,int l, int r)
    {
        if(l >= r) return 0;
        int m = (l+r) / 2;
        int count = merge_sort(nums, temp, l, m) + merge_sort(nums, temp, m+1, r);
        
        int i=l, j = m+1, pos = l;
        while(i<=m && j<=r)
        {
            if(nums[i] <= nums[j])
            {
                temp[pos] = temp[i];
                i++;
                //[1,2,5,3] [4,6,8,7]
                //     .       .
                //只有当l指针移动时，计算r指针距离m+1的距离为当前逆数组个数
                count += j - (m+1);
            }
            else
            {
                temp[pos] = temp[j];
                j++;
            }
            pos++;
        }
        for(int k=i; k<=m; k++)
        {
            temp[pos++]=temp[k];
            count += j - (m+1);
        }
        for(int k=m+1; k<=r; k++)
        {
            temp[pos++] = temp[k];
        }
        copy(temp.begin()+l, temp.begin()+r+1,nums.begin()+l);
        return count;
    }
};
```


## 2.为表达式设计优先级

题目描述
输入：expression = "2-1-1"
输出：[0,2]
解释：
((2-1)-1) = 0 
(2-(1-1)) = 2



输入：expression = "2*3-4*5"
输出：[-34,-14,-10,-10,10]
解释：
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10

                                        2*3 - 4*5
                        2 * (3-4*5) r[2* [-5, -17]]              (2*3) - (4*5)
       2*((3-4)*5) r[2* -5]        2*((3-(4*5))) r[2 * -17]
             r[-1]                     r[20]




```C++
class Solution {
public:
    vector<int> diffWaysToCompute(string expression) {
       
       return merge_add(expression);
    }

    vector<int> merge_add(string s)
    {
       if(is_int(s))
       {
           return {atoi(s.c_str())};
       }
       vector<int> res;
       for(int i=0; i<s.size(); i++)
       {
           if(s[i] == '+' || s[i] == '-' || s[i] == '*')
           {
                // 1.分解：遇到运算符，计算左右两侧的结果集
                // 2.解决：merge_add 递归函数求出子问题的解
                vector<int> left = merge_add(s.substr(0, i));
                vector<int> right = merge_add(s.substr(i+1,s.size()-1-i));

                //3.合并
                for(auto l:left)
                {
                    for(auto r:right)
                    {
                        if(s[i] == '+')
                        {
                            res.push_back( l + r);
                        }
                        else if(s[i] == '-')
                        {
                            res.push_back(l -r);
                        }
                        else
                        {
                            res.push_back(l * r);
                        }
                    }
    
                }
            }
       }
       return res;
    }

    bool is_int(string s)
    {
        for(auto c:s)
        {
            if(c >= '0' && c <= '9')
            {
                continue;
            }
            else
            {
                return false;
            }
        }
        return true;
    }

};
```




# 位运算

&与运算；
|或运算；
~按位取反；
^按位异或；不同取1；
<< 左移，正数左移n位相当于扩大2^n倍，负数无明显意义；
>> 右移，正数右移n位相当于缩小2^n倍;

n&(n-1)可以去除n二进制中最右边的1,
如11110100 ，减一得到11110011, 按位与得 11110000；
n&(-n)可以保留n二进制中最右边的1，
如11110100, 取负数，先按位反得00001011，再加1得-n为00001100， 按位与得到00000100


## 461 汉明距离

输入是两个十进制整数，输出是一个十进制整数，表示两个输入数字的汉明距离。

Input: x = 1, y = 4
Output: 2
在这个样例中，1 的二进制是 0001，4 的二进制是 0100，一共有两位不同。

```c++
int hanmingdistance(int x, int y)
{
    int dif = x^y;
    int res = 0;
    //求二进制中多少个1的思路:判断当前最右边是否为1，然后右移；
    while(dif)
    {
        res += dif & 1;
        res >>= 1;
    }
    return res;
}


```



# 字符串

## 1.分割字符串

intput: str = "  aae   eer  eref ff ";

output : {aae, eer, eref, ff};

```c++

class solution
{
public:
    vector<string> splitstring(string str)
    {
        //去除首尾的空格；
        int i=0;
        int n=str.size()-1;
        while(str[i]==' ') i++;
        while(str[n]==' ') n--;
        str = str.substr(i,n-i+1);

        vector<string> res;
        int pos = str.find(' ');
        while(pos != str.npos)
        {
            string temp = str.substr(0,pos);
            res.push_back(temp);
            while(str[pos] == ' ') pos++;
            str = str.substr(pos, str.size());
            pos = str.find(' ');
        }
        res.push_back(str);

        return res;
        
    }
};

```


## 2. 统计包含e的单词数
intput: str = "  aae   eer  eref ff ";

output :3;

```c++


class solution
{
public:
    int splitstring(string str)
    {
        //去除首尾的空格；
        int i=0;
        int n=str.size()-1;
        while(str[i]==' ') i++;
        while(str[n]==' ') n--;
        str = str.substr(i,n-i+1);

        vector<string> res;
        int pos = str.find(' ');
        while(pos != str.npos)
        {
            string temp = str.substr(0,pos);
            res.push_back(temp);
            while(str[pos] == ' ') pos++;
            str = str.substr(pos, str.size());
            pos = str.find(' ');
        }
        res.push_back(str);

        int k=0;
        for(auto s : res)
        {
            for(auto c:s)
            {
                if(c=='e' || c=='E')
                {
                    k++;
                    break;
                }
            }
        }
        return k;
        
    }
};

```


```c++
class Solution {
public:
    int hammingDistance(int x, int y) {

        int dif = x ^ y;
        int res = 0;
        //求二进制中多少个1的思路2:利用n^(n-1)去除最右边的1
        while(dif>0)
        {
            dif = dif & (dif-1);
            res++;
        }
        return res;

    }
};

```



# 链表

结构代码：
```C++

struct ListNode
{
    int val;
    ListNode *next;
    ListNode(): val(0),next(nullptr) {};
    ListNode(int x): val(x),next(nullptr) {};
    ListNode(int x, ListNode *next):val(x),next(next){};
}

```

## 1.合并两个升序链表

**1.递归**

```C++

class solution
{
public:
    ListNode* mergetwolists(ListNode* list1, ListNode* list1)
    {
        ListNode* head = new ListNode();
        ListNode* temp = head;
        dfs(temp,list1,list2);
        return head->next;
    }
    void dfs(ListNode* temp, ListNode* list1, ListNode* list2)
    {
        if(!list1 || !list2)
        {
            temp->next = !l1 ? l2 : l1;
            return;
        }
        if(list1->val<list2->val)
        {
            temp->next = list1;
            dfs(temp->next,list1->next, list2);
        
        }
        else
        {
            temp->next = list2;
            dfs(temp->next,list1,list2->next);
        }
    }
}
```
**2.迭代**


```C++

class solution
{
public:
    ListNode* mergetwolists(ListNode* list1, ListNode* list2)
    {
        ListNode* head = new ListNode();
        ListNode* temp = head;



        while(list1 && list2)
        {
            if(list1->val < list2->val)
            {
                temp->next = list1;
                list1 = list1->next;
            }
            else
            {
                temp->next = list2;
                list2 = list2->next;
            }
            temp = temp->next;
        }

        temp->next = list2==nullptr ? list1 : list2;

        return head->next;
    
    }
}


```


## 2.合并k个升序链表(23)

```C++
class solution
{
public:
    ListNode* mergeklists(vector<ListNode*>& lists)
    {
        if(lists.empty())
        {
            return nullptr;
        }
        int len=lists.size();

        return merge(lists,0,len-1);
    }

    ListNode merge(vector<ListNode*>& lists, int l, int r)
    {
        if(l==r)
        {
            return lists[l];
        }
        int mid = (l+r) / 2;
        ListNode* leftlist = merge(lists, l, mid);
        ListNode* rightlist = merge(lists, mid+1, r);

        return mergetwolists(leftlist, rightlist);
    }
    ListNode* mergetwolists(ListNode* list1, ListNode* list2)
    {
        ListNode* head = new ListNode();
        ListNode* temp = head;

        while(list1 && list2)
        {
            if(list1->val < list2->val)
            {
                temp->next = list1;
                list1 = list1->next;
            }
            else
            {
                temp->next = list2;
                list2 = list2->next;
            }
            temp=temp->next;
        }

        temp->next = list2==nullptr ? list1 : list2;
        return head->next;
    }
}

```


## 3.反转链表(206)


**1.迭代**
```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr, *next;
        while(head)
        {
            next = head->next; //保存下一节点
            head->next = prev; //更改当前节点指向；

            prev = head;  //更新前节点和当前节点
            head = next;
        }
        return prev;
    }

```


**2.递归**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr, *next;
        return help(prev, head, next);

    ListNode* help(ListNode *prev, ListNode *head, ListNode *next)
    {
        if(!head)
        {
            return prev;
        }
        next = head->next;
        head->next = prev;

        return help(head, next, next);
    }
```


## 4.复制复杂链表(剑指offer35)

如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。
prev = new ListNode();
temp = new ListNode(head->val);
prev->next = temp;

而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。
prev->random = ?


分析：如果能根据当前遍历的head，head->next,head->random有直接映射一个ListNode(val);


```c++
//遍历
class solution
{
public:
    Node copyRandomList(Node* head) 
    {
        if(!head) return nullptr;
        unordered_map<Node*, Node*> umap;
        //先把所有node都创建出来
        for(auto p = head; p != nullptr; p = p->next)
        {
            umap[p] = new Node(p->val);
        }
        //再次遍历节点进行copy
        for (auto p = head; p != nullptr; p = p->next)
        {
            umap[p]->next = umap[p->next];
            umap[p]->random = umap[p->random];
        }
        return umap[head];
    }
}


```

```c++
//递归
class solution
{
public:
    unordered_map<Node*, Node*> umap;
    Node copyRandomList(Node* head)
    {

        if(!head) return nullptr;
        umap[head] = new Node(head->val);
        
        umap[head]->next = copyRandomList(head->next);

        umap[head]->random = nullptr;
        //random指针通过回溯自底向上初始化
        if(head->random != nullptr)
        {
            umap[head]->random = umap[head->random];
        }
        

        return umap[head];
        
    }
}

```


## 5.二叉搜索树与双向链表(剑指offer36)

将二叉树搜索树转换为以排序好的双向链表

记忆：二叉搜索树的中序遍历为升序；

```c++
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
class solution
{
public:
    Node* head = new Node();
    Node* temp = head;
    Node* prev = nullptr;
    Node* treeToDoublyList(Node* root)
    {

       if(!root) return nullptr;
       mfs(root);

       head->right->left = temp;
       temp->right = head->right;

       return head->right;

    }

    void mfs(ListNode* root)
    {
        if(!root) return;

        mfs(root->left);

        temp->right = root;
        root->left = temp;
        prev = temp;
        temp = temp->right;

        mfs(root->right);
    }
}




```


## 6.返回两个链表中的第一个公共节点
    a
    ____
        |
________ ______________
   b            c


证明:a + c + b = b + c + a;




```C++
//双指针+规律
class solution
{
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        if(headA == nullptr || headB == nullptr) return nullptr;
        ListNode* p1 = headA, *P2 = headB;
        while(p1 != p2)
        {
            p1 = p1 == nullptr ? headB : p1->next;
            p2 = p2 == nullptr ? headA : p2->next;
        }

        return p1;
    }
}





```
## 7.链表中环的入口节点

```C++

//哈希表
class Solution
{
    ListNode *detectcycle(ListNode* head)
    {
        unordered_map<ListNode*, int> mp;
        while(head != nullptr)
        {
            mp[head]++;
            if(mp[head] == 2)
            {
                return head;
            }
            head = head->next;
        }
        return NULL;
    }
}

```




## 8.删除链表中重复节点

```C++
//哈希表
ListNode* deleteduplicates(ListNode* head)
{
    unordered_map<int, int> mp;
    ListNode* temp = head;
    ListNode* prev = nullptr;
    while(temp != nullptr)
    {
        if(mp.count(temp->val))
        {
            prev->next = temp->next;
            temp = temp->next;
            continue;
        }
        mp[temp->val]++;
        prev = temp;
        temp = temp->next;
    }
    return head;
}



```C++




# 数组 

## 1.旋转数组

题目描述:输入非降序数组，返回旋转数组最小值;

输入：
[3,4,5,1,2]
返回值：
1

输入：
[3,100,200,3]
返回值：
3


```C++

int rotatearray_midfing(vector<int> arr)
{
    int l = 0, r = arr.size()-1;
    int mid;
    while(l < r)
    {
        mid = (l + r) / 2;
        if(arr[mid] < arr[r]) //说明右边有序，入口在左边
        {
            r = mid;
        }
        else if(arr[mid] > arr[r]) //说明左边有序，入口在右边
        {
            l = mid + 1;
        }
        else //找到入口，跳出
        {
            r--；
        }
    }
    return arr[l];
}

```



# 栈


## 栈的压入，弹出序列


题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true

push(1) push(2) push(3) push(4) pop()4, push(5), pop(5) pop(3), pop(2), pop(1);

输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出


规律：4能在5之前弹出，说明4在5 push之前pop, 1在2之前弹出，说明1在2push之前pop 明显不符合出栈序列；

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> st;
        int i = 0;//记录poped的索引；
        for(auto value : pushed)
        {
            st.push(value);
            while(!st.empty() && st.top()==popped[i])
            {
                st.pop();
                i++;
            }
        }
        if(st.empty())
        {
            return true;
        }
        else
        {
            return false;
        }

    }
};

```



## 单调栈


### 1.每日温度

给定每天的温度，求对于每一天需要等几天才可以等到更暖和的一天。如果该天之后不存在
更暖和的天气，则记为 0。
Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]

```c++
class solution
{
public:
    vector<int> dailytemptures(vector<int>& nums)
    {
        int n = nums.size();
        vector<int> res(n);
        stack<int> index;
        for(int i=0; i<n; i++)
        {
            while(!index.empty())
            {
                int pre_index = index.top();
                if(nums[i] > nums[pre_index])
                {
                    index.pop();
                    res[pre_index] = i-pre_index;
                }
                else
                {
                    break;
                }

            }

            index.push(i);
        }
    }
}

```


### 2.最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

```C++

class solution
{
public:
    stack<int> st;
    stack<int> minstack;
    Minstack(){};

    void push(int val)
    {
        if(st.empty() && minstack.empty())
        {
            st.push(val);
            minstack.push(val);
        }
        else
        {
            st.push(val);
            if(val < minstack.top())
            {
                minstack.push(val);
            }
            else
            {
                minstack.push(minstack.top());
            }
        }


    }
    void pop()
    {
        st.pop();
        minstack.pop();

    }
    void top()
    {
        st.top();

    }
    int getmin()
    {
        minstack.top();
    }
}


```


# 树

```C++
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x): val(x),left(NULL),right(NULL) {}

};

```





## 树的遍历

### 前序遍历(深度优先)

1.递归

```C++


void dfs(TreeNode* root)
{
    if(!root)
    {
        return;
    }
    func(root->val);
    dfs(root->left);
    dfs(root->right);

}


```

2.栈

```C++
#include <stack>

void dfs(TreeNode* root)
{
    stack<TreeNode*> q;
    q.push(root);
    while(!q.empty())
    {
        TreeNode* temp = q.top();
        q.pop();
        func(temp->val)
        if(temp->right)
        {
           q.push(temp->right);
        }
        if(temp->left)
        {
            q.push(temp->left);
        }
    }
    return;
}



```

### 层序遍历(广度优先)

1.queue实现(递归反而更难理解)

```C++
#include<queue>
void bfs(TreeNode* root)
{
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty())
    {
        int breadth = q.size();  //计算每层宽度并遍历不是必要的
        for(int i=0; i<breadth; i++)
        {
            TreeNode* temp=q.front();
            q.pop();
            func(temp->val);
            if(temp->left)
            {
                q.push(temp->left);
            }
            if(temp->right)
            {
                q.push(temp->right);
            }
        }

    }
    return;

}

```


### 中序遍历

```C++

void mfs(TreeNode* root)
{
    if(!root) return;
    mfs(root->left);
    func(root->val); //回溯
    mfs(root->right)
}

```

### 后续遍历

```C++

void lfs(TreeNode* root)
{
    if(!root) return;
    lfs(root->left);
    lfs(root->right);
    func(root->val);
}
```


### 二叉树所有路径(257)

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。


输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]


```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
   vector<string> binaryTreePaths(TreeNode* root) {
        vector<int> path;
        vector<vector<int>> res1;

        dfs(root, path, res1);

        vector<string> res;

        convert(res1, res);
        
		return res;

    }
    void convert(vector<vector<int>>& res1, vector<string>& res)
    {
        string temp = "";
        int pos = 0;
        for(auto it : res1)
        {
            for(auto num : it)
            {
                temp += to_string(num);
                temp += "->";
            }
            pos = temp.size()-1;
            temp.erase(pos-1,2);
            res.push_back(temp);
            temp = "";
            
        }
    }
    void dfs(TreeNode* root, vector<int>& path, vector<vector<int>>& res1)
    {

        if(root==nullptr) return;

        path.push_back(root->val);

        if(root->left == nullptr && root->right == nullptr)
        {
            res1.push_back(path);
        }

        dfs(root->left, path, res1);
        dfs(root->right, path, res1);

        path.pop_back();


    }
};

```

### 二叉树中和为某值得路径(34)
题目描述：
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

```C++

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int target) {

        vector<vector<int>> res;
        if(!root) return res;
        vector<int> path;

        dfs(root, target, res, path);

        return res;
    }

    void dfs(TreeNode* root, int &target, vector<vector<int>>& res, vector<int>& path)
    {
        //递归出口为叶子结点，下一空节点
        if(root == nullptr)
        {
            return;
        }
        path.push_back(root->val);
        target = target - root->val;

        if(target == 0 && root->left == nullptr && root->right == nullptr)
        {
            res.push_back(path);
            //此处如有return ,pop会不正确
        }

        
      
        dfs(root->left, target, res, path);
        dfs(root->right,target, res, path);
      
        path.pop_back();
        target = target + root->val;
    


    }
};



```


### 平衡二叉树与树的深度

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
输入：root = [3,9,20,null,null,15,7]
输出：true


分析：最直接的做法，遍历每个结点，借助一个获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。


```c++

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {

        if(root==nullptr) return true;

        return abs(maxdepth(root->left) - maxdepth(root->right)) <= 1 && 
            isBalanced(root->left) && isBalanced(root->right);

    }

    int maxdepth(TreeNode *node)
    {
        if(node==nullptr) return 0;
        int left = maxdepth(node->left);
        int right = maxdepth(node->right);

        return 1 + max(left, right);
    }
};
```
### Z字形打印树节点

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        vector<vector<int>> res;
        if(!root) return res;

        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int width = q.size();
            vector<int> nums;
            for(int k=0; k<width; k++)
            {
                TreeNode* temp = q.front();
                q.pop();

                nums.push_back(temp->val);

                if(temp->left)
                {
                    q.push(temp->left);
                }
                if(temp->right)
                {
                    q.push(temp->right);
                }
            }
            res.push_back(nums);
        }
        for(int i=0; i<res.size(); i++)
        {
            if(i % 2 != 0)
            {
                reverse(res[i].begin(),res[i].end());
            }
        }
        return res;

    }
};

```

### 二叉搜索树的第k大节点(中序遍历)

给定一颗而叉搜索树，请找出其中第k大的节点的值

分析：二叉搜索树的中序遍历为递增排序，反中序遍历为递减排序；


```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int level = 0;
    int kthLargest(TreeNode* root, int k) {

        int res = 0;
        mfs(root, res, k);
        return res;
    }

    void mfs(TreeNode* root, int& res, int k)
    {
        if(root==nullptr) return;

        mfs(root->right, res, k);
        
        level++;
        if(level == k)
        {
            res = root->val;
            return;
        }

        mfs(root->left, res, k);
    
    }
};

```

###   二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 

```c++


// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};


class Solution
{
public:
    Node *head = new Node();
    Node *temp = head;
    Node *prev = nullptr;

    Node* treeToDoublyList(Node* root)
    {
        //二叉搜索树的中序遍历为升序链表
        if(root == nullptr) return nullptr;

        mfs(root);
        head->right->left = temp;
        temp->right = head->right;
        return head->right;
    }

    void mfs(Node* root)
    {
        if(root == nullptr) return;

        mfs(root->left);
        temp->right = root;
        root->left = temp;

        prev = temp;
        temp = temp->right;
        mfs(root->right);
    }
}

```



#### 递归与非递归



问题：将字符串中的所有数值，转换成数值并输出，要求使用递归方式
input:"jasfg2a45646a fa6387af364";
output:2
       45646
       6387
       364


```C++

//非递归解法
#include <iostream>
#include <vector>
using namespace std;
void ndfs(string in,vector<int > &res);
int main()
{
    string in ="jasfg2a45646a fa6387af364";
    vector<int > res;
    ndfs(in, res);
    for(int i=0;i<res.size();i++)
      cout<< res[i] <<endl;
    cout << "res.size()="<< res.size()<< endl;
    return 0;
}

void ndfs(string in, vector<int>& res)
{
    int i=0, val=0; //i为遍历位置的下标,val为当前连续数值
    while(i<in.size())  //循环出口为递归出口;
    {
        while(in[i]>='0' && in[i]<='9')
        {
            val = val*10 + (in[i]-'0');
            i++;
        }
        if(val)
        {
            res.push_back(val);
            val = 0;
        }
        i++;  //递归入口
    }
}


```




```C++

//递归解法
#include <iostream>
#include <vector>
using namespace std;
void dfs(string in, int i, int val, vector<int > &res);
int main()
{
    string in ="jasfg2a45646a fa6387af364";
    vector<int > res;
    dfs(in,0,0 res);
    for(int i=0;i<res.size();i++)
      cout<< res[i] <<endl;
    cout << "res.size()="<< res.size()<< endl;
    return 0;
}
void dfs(string in, int i, int val, vector<int > &res)  //循环外的初始化值i,val作为递归的入口参数
{
    if(i>in.size()) //递归出口
    {
        return;
    }
    while(in[i]>='0' && in[i]<='9')
    {
        val = val*10 + (in[val]-'0');
        i++;
    }
    if(val)
    {
        res.push_back(val);
        val=0;
    }
    //递归入口
    dfs(in,i++,val,res);
}
```





## 树的递归

### 二叉树镜像

     4
   /   \
  2     7
 / \   / \
1   3 6   9


     4
   /   \
  7     2
 / \   / \
9   6 3   1

``` c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {

        reverse(root);

        return root;

    }

    void reverse(TreeNode* root)
    {
        if(!root)
        {
            return;
        }
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;

        reverse(root->left);
        reverse(root->right);
    }
};
```

### 对称二叉树

                    1
        2                      2
    3       4           4            3
  7   6   3   4      4     3      6     7


  ```c++

class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;

        return isequal(root->left, root->right);

    }
    bool isequal(TreeNode* leftnode, TreeNode* rightnode)
    {

        if(leftnode==nullptr && rightnode==nullptr) return true;
        if(leftnode==nullptr || rightnode==nullptr) return false;
        if(leftnode->val == rightnode->val)
        {
            return isequal(leftnode->left, rightnode->right) && isequal(leftnode->right, rightnode->left);
        }
        else
        {
            return false;
        }
    }

};

  ```


### 二叉搜索树的后序遍历序列

题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。


     5
    / \
   2   6
  / \
 1   3
输入: [1,6,3,2,5]
输出: false

输入: [1,3,2,6,5]
输出: true



```c++

class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        if(postorder.empty()) return true;
    
        return fenzhi_vertify(postorder, 0, postorder.size()-1);

    }

    bool fenzhi_vertify(vector<int>& postorder, int low, int hight)
    {
        //递归出口，子树节点为1；
        if(low >= hight) return true;

        //划分左右子树
        //二叉树搜素树的后序遍历，根节点在vector最后, 找到第一个大于根节点的元素，即可找出左子树
        int start = low;
        while(start < hight && postorder[start] < postorder[hight]) start++;
        //[low,start-1]为左子树, [start, hight-1]为左子树，只需验证右子树的正确性
        for(int i = start; i < hight; i++)
        {
            if(postorder[i] <= postorder[hight]) return false;
        }

        return fenzhi_vertify(postorder,low,start-1) && fenzhi_vertify(postorder,start, hight-1);

    }
};
```



# 堆



## 数据流的中位数


设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。


```c++

class MedianFinder {
public:
    /** initialize your data structure here. */
    priority_queue<int, vector<int>, less<int>> maxheap;
    priority_queue<int, vector<int>, greater<int>> minheap;
    MedianFinder() {

    }
    
    void addNum(int num) {
        //假如插入的元素为N，N为偶数时，大顶堆维护前top N/2大的数据，小顶堆维护后top N/2大的数据，中位数为 N/2和N/2+1大的数求平均；
        //N为基数,大顶堆维护前top N+1/2大的数， 小顶堆维护后top N/2大的数，中位数为N+1/2
        /*
         * 当两堆的数据个数相等时候，左边堆添加元素。
         * 采用的方法不是直接将数据插入左边堆，而是将数据先插入右边堆，算法调整后
         * 将堆顶的数据插入到左边堆，这样保证左边堆插入的元素始终是右边堆的最小值。
         * 同理左边数据多，往右边堆添加数据的时候，先将数据放入左边堆，选出最大值放到右边堆中。
         */
        if(maxheap.size() == minheap.size())
        {
            minheap.push(num);
            int top = minheap.top();
            minheap.pop();
            maxheap.push(top);
        }
        else
        {
            maxheap.push(num);
            int top = maxheap.top();
            maxheap.pop();
            minheap.push(top);
        }


    }
    
    double findMedian() {

        if(maxheap.size() == minheap.size())
        {
            return (maxheap.top() + minheap.top())*1.0 / 2;
        }
        return maxheap.top() * 1.0;

    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */

```


## 滑动窗口最大值
给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 

```c++

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

      if(nums.size()==0 || k==0 || k>nums.size()) return vector<int>();
      int n =nums.size();
      priority_queue<pair<int,int>> q;
      for(int i=0; i<k; i++)
      {
          q.push({nums[i],i});
      }
      vector<int> res = {q.top().first};

      for(int j=k; j<n; j++)
      {
          q.push({nums[j],j});
          //如果堆顶最大元素在当前滑动窗口左边界之外，则移除；
          while(q.top().second <= j-k)
          {
              q.pop();
          }
          res.push_back(q.top().first);
      }
      return res;



    }
};
```
# 设计模式

## 1.单例模式

单例模式的目的是保一个类只有一个实例，并提供一个访问他的全局访问点，该实例被所有程序模块共享；
实现步骤：
	构造函数私有化，避免外部使用构造函数来创建对象；
	增加静态私有的当前类的指针变量(记录之前是否有过实例);
	提供静态的public接口，可以让用户获得单例；

### 1.1懒汉式(经典线程安全懒汉)
单例模式的实现思路如前述所示，其中，经典的线程安全懒汉模式，使用双检测锁模式。

```C++

class single{
private:
    //私有静态指针变量指向唯一实例
    static single *p;

    //私有化构造函数
    single(){};
    ~single(){};

    public:
    //公有静态方法获取实例
    static single* getinstance()
    {
        if(NULL==p)
        {
            std::lock_guard<std::mutex> lock();
            if(NULL==p)
            {
                p = new single();
            }
        }
        return p;
    }

};

single* single::p = NULL;

```

```c++
//单效验
static single* getinstance()
    {
      
        std::lock_guard<std::mutex> lock();
        if(NULL==p)
        {
            p = new single();
        }
        return p;
    }

```

为什么要用双检测，只检测一次不行吗？
如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，
仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。

### 1.2懒汉式(静态变量之线程安全懒汉) 
不安全，但C++11标准之后，要求编译器保证内部静态变量的线程安全性
优点：
第一次调用的时候才初始化，避免内存浪费；
缺点：
必须加锁才能保证单例，加锁会影响效率；

```C++

class CSingleton
{
private:
    CSingleton(){};  //构造函数时私有的；

    static CSingleton *m_pInstance;
    class help
    {
    public:
        ~help()
        {
            if(CSingleton::m_pInstance)
            {
                delete CSingleton::m_pInstance;
            }
        }
    }
    static help a;  //定义一个静态成员变量，程序结束时，系统自动调用它的析构函数(程序结束时，系统会自动析构所有全局变量和所有类的静态成员变量；)
public:
    static CSingleton *GetInstance()
    {
        if(m_Instance==NULL)  //判断是否为第一次调用
        {
            m_pInstance = new CSingleton();
        }
        return m_pInstacne;
    }
};
//类外初始化
CSingleton* CSingleton::m_PInstance =NULL;
//用户访问唯一实例的方法只有GetInstance()成员函数。如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的。
//GetInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的。这是一种防弹设计――所有GetInstance()之后的调用都返回相同实例的指针：

CSingleton* p1 = CSingleton :: GetInstance();
CSingleton* p2 = p1->GetInstance();
CSingleton & ref = * CSingleton :: GetInstance();

```




```C++
//局部静态成员变量
class Singleton
{
public:
    static Singleton* getinstance()
    {
        static Singleton* instacne;
        return instance;
    }
}


```



### 1.2饿汉式

优点：不需要加锁，本身线程安全；
缺点：不管用不用都会初始化，浪费内存；


**使用局部静态变量**实现，需显示声明类的拷贝构造函数和重载=操作符

```C++

class single
{
private:
    static single* p ;
    single(){};
    ~single(){};
public:
    static single* getinstance()
    {
        return p;
    }

};
single* single::p = new single();
//测试方法
int main(){
    single *p1 = single::getinstance();
    single *p2 = single::getinstance();

    if (p1 == p2)
    {
        cout << "same" << endl;
    }
    system("pause");
    return 0;
```
## 2.观察者模式

观察者模式定义了一种一对多的依赖关系，使得该对象状态变化时，所有订阅过它的对象都会得到通知并进行更新；

应用场景：
当一个对象的改变需要同时改变其他对象，且不知道具体有多少个对象待改变，应该考虑使用观察者模式；
一个抽象模型有两个方面，其中一个方面依赖于另外一方面时，可以使用观察者；

```C++
#include<iostream>
#include<string>
#include<list>
using namespace std;


class Observed;  //被观察者声明；

//观察者基类(内部实例化了被观察者对象observed)
class Observer
{
protected:
    string name;
    Observed *observed;

public:
    Observe(string name, Observed *observed)
    {
        this->name = name;
        this->observed = observed;
    }
    virtual void update()=0;

};

//被观察者基类(内部存放所有的观察者对象,以便状态发生变化时，给观察者发通知)
class Observed
{
protected:
    list<Observer *> observers;

public:
    string action;  //被观察者对象的状态
    virtual void attach(Observer *) =0;
    virtual void detach(Observer *) =0;
    virtual void notify() = 0;

};

class Stockobserver:public Observer
{
public:
    Stockobserver(string name, Observed *observed): Observer(name, observed)
    {

    }
    void update();
};

class NBAobserver: public Observer
{
public:
    NBAobserver(string name, Observed * observed):Observer(name, observed)
    {

    }
    void update();
};


class Secretary: public observed
{
    void attach(Observer * observer)
    {
        observers.push_back(observer);
    }
    void detach(Observer *observer)
    {
        list<Observer *>::iterator iter = observers.begin();
        while(iter != observers.end())
        {
            if((*iter) == observer)
            {
                observers.erase(iter);
                return;
            }
            iter++;
        }
    }

    void notify()
    {
        list<Observer *>::iterator iter = observers.begin();
        while(itet != observers.end())
        {
            (*iter)->update();
            iter++;
        }
    }
}

void Stockobserver::update()
{
    cout << name << " 收到消息：" << observed->action << endl;
    if (observed->action == "梁所长来了!")
    {
        cout << "我马上关闭股票，装做很认真工作的样子！" << endl;
    }
}

void NBAobserver::update()
{
    cout << name << " 收到消息：" << observed->action << endl;
    if (observed->action == "梁所长来了!")
    {
        cout << "我马上关闭NBA，装做很认真工作的样子！" << endl;
    }
}

int main()
{
    Observed *dwq = new Secretary();
    Observer *xs = new NBAobserver("xiaoshuai",dwq);
    Observer *zy = new NBAobserver("zuoye",dwq);
    Observer *lm = new Stockobserver("limin",dwq);

    dwq->attach(xs);
    dwq->attach(zy);
    dwq->attach(lm);

    dwq->action = "去吃饭了！";
    dwq->nptify();
    
    dwq->action = "梁所长来了";
    dwq->notify();
    return 0;
}



```



# 写三个线程交替打印ABC


```C++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

//初始化互斥锁和条件变量；
mutex mylock;
condition_variable cv;

//线程之间，通过全局变量通信
int flag = 0;


void printa()
{
    //可以随时加锁解锁
    //作用域规则同 lock_grard，析构时自动释放锁
    unique_lock<mutex> lock(mylock);
    int count = 0 ;
    while(count < 10)
    {
        //等于0,A线程打印
        while(flag != 0) cv.wait(lock);
        cout << "thread1 : A" << endl;
        flag = 1;
        cv.notify_all();
        count++;
    }
    cout << "thread1 finish" << endl;
}

void printb()
{
    unique_lock<mutex> lock(mylock);
    for(int i=0; i<10; i++)
    {
        while(flag != 1) cv.wait(lock);
        cout << "thread2 : B" << endl;
        flag = 2;
        cv.notify_all();
    }
    cout << "thread2 finish" << endl;
}

void printc()
{
    unique_lock<mutex> lock(mylock);
    for(int i=0; i< 10; i++)
    {
        while(flag != 2) cv.wait(lock);
        cout << "thread3 : C" << endl;
        flag = 0;
        cv.notify_all();

    }
    cout << "thread2 finish" << endl;
}

int main()
{
    thread thread1(printa);
    thread thread2(printb);
    thread thread3(printc);

    thread1.join();
    thread2.join();
    thread3.join();

    cout << "main thread" << endl;
}




```